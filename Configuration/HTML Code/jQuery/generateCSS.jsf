//Since text and artwork properties have to be placed inside a single class, these variables are used to check if one of objects is already called.var check_bar = false;var check_body = false;var check_buttonDown = false;var check_buttonUp = false;var check_buttonHover = false;var check_active = false;var invalidFont = false;var CSSGlobalIconDisc = ""; //This is to be used while replacing the ui-icon in the 4 files generated for iconsvar isBold = false; //required for ui-link//Since text and artwork properties have to be placed inside a single class, associative arrays with indexes as respective design aspect is used to store the properties of the object that has been called firstvar swatchCSSArr = new Array();/*swatchCSSArr['ui_bar'], swatchCSSArr['ui_body'], swatchCSSArr['ui_button_up'], swatchCSSArr['ui_button_down'], swatchCSSArr['ui_button_hover'], swatchCSSArr['ui_active']swatchCSSArr['ui-link']For all objects font family property has to be placed inside a separate class each for bar,body and buttonswatchCSSArr['bar_fontFamily'],swatchCSSArr['body_fontFamily']*///Include all font family inside a single array to place it inside @font-facevar fontFamilyArr = new Array();//To generate unique swatch namesvar swatchNameArr = new Array();var scntr = 1;	//This is the swatch counter//This is the variable containing the CSS for all the objects and will be used in the main function of all the other three scriptsvar entireCSS = "";function __main(){		var swatchName = "";	var dom = fw.getDocumentDOM();	var numPages = dom.pagesCount;		var currPage = dom.currentPageNum;	isBold = false;	if(typeof fromPreview == 'undefined')	{	  fromPreview = false;	}	if(typeof generateOnlySprites == 'undefined')	{	  generateOnlySprites = false;	}	if(true == generateOnlySprites)	{		CSSGlobalIconDisc = ""; 		__parseGlobalIconDisc(fw.getDocumentDOM());		generateOnlySprites = false;	}	else if(fromPreview == true)	//If the code is called from preview	{		if((currPage == 0) && (numPages > 1))	//If the sprites page is selected, show the preview of the first page			dom.changeCurrentPage(1);		entireCSS = "";				if(typeof exportCurrentSwatch == 'undefined')		{		  exportCurrentSwatch = false;		}		if(exportCurrentSwatch == true)	//If the code is called from preview and if the user wants to export the current swatch		{			swatchName = fw.getDocumentDOM().pageName;			swatchName = swatchName.replace(/[\W]/g,"_");			swatchName = __generateAptName(swatchName);		}		else			swatchName = "a";			//Check if swatch name is empty,undefined or  null and generate the CSS for it. If its not(it mustn't be since the conditions are handled in the previous statements.		//var linkjQueryCSS = "";		if(swatchName != "")			if(!(__CheckIfDoubleBytePresent(swatchName)))				if(swatchName != undefined) 				{					entireCSS += __parseCSS(fw.getDocumentDOM(),swatchName);					fw.getDocumentDOM().selectNone();					if(!exportCurrentSwatch)					{						dom.changeCurrentPage(0);						if(entireCSS != "")						{							swatchCSSArr['ui_active_forIcon'] = "";							entireCSS += __parseActiveButton(fw.getDocumentDOM());							if("" != swatchCSSArr['ui_active_forIcon'])								entireCSS += ".ui-checkbox-on .ui-icon,\n.ui-radio-on .ui-icon {\n" + 			  swatchCSSArr['ui_active_forIcon'] + "\n}\n";							entireCSS += __parseGlobalRadii(fw.getDocumentDOM());							CSSGlobalIconDisc = ""; 							__parseGlobalIconDisc(fw.getDocumentDOM());							entireCSS += __parseGlobalShadowProperties(fw.getDocumentDOM());							entireCSS += __fontFaceCSS(fontFamilyArr);							entireCSS += __includeAdditionalCSSCode();						}					}				}	fw.getDocumentDOM().selectNone();	dom.changeCurrentPage(currPage);	fw.getDocumentDOM().selectNone();	fromPreview = false;	exportCurrentSwatch = false;	}	else	{		entireCSS = "";		if(numPages > 1) 	//If the number of pages is greater than one select the page name or some default name as the swatch name or else its an error so its ignored 		{			entireCSS = "";//Iterate through all the pages						for(var num = 1 ; num < fw.getDocumentDOM().pagesCount ; num++)			{								dom.changeCurrentPage(num);				swatchName = fw.getDocumentDOM().pageName;				//Replace anything other than alphanumeric to null				swatchName = swatchName.replace(/[\W]/g,"_");				swatchName = __generateAptName(swatchName);				//Check if swatch name is empty,undefined or  null and generate the CSS for it. If its not(it mustn't be since the conditions are handled in the previous statements.				if(swatchName != "")					if(!(__CheckIfDoubleBytePresent(swatchName)))						if(swatchName != undefined) 						{							entireCSS += __parseCSS(fw.getDocumentDOM(),swatchName);						}							}			}		//Include Values for Active button		swatchCSSArr['ui_active_forIcon'] = "";		dom.changeCurrentPage(0);		entireCSS += __parseActiveButton(fw.getDocumentDOM());		if("" != swatchCSSArr['ui_active_forIcon'])			entireCSS += ".ui-checkbox-on .ui-icon,\n.ui-radio-on .ui-icon {\n" + swatchCSSArr['ui_active_forIcon'] + "\n}\n";            CSSGlobalIconDisc = ""; 		entireCSS += __parseGlobalRadii(fw.getDocumentDOM());		__parseGlobalIconDisc(fw.getDocumentDOM());		entireCSS += __parseGlobalShadowProperties(fw.getDocumentDOM());		if(entireCSS != "")		{			//Including @fontface properties for all the fonts used			entireCSS += __fontFaceCSS(fontFamilyArr);			entireCSS += __includeAdditionalCSSCode();		}				fw.getDocumentDOM().selectNone();			dom.changeCurrentPage(currPage);			fw.getDocumentDOM().selectNone();	}}//Check for duplicate names and invalid swatch namesfunction __generateAptName(sname){	var newName = "";	var x = 0;	newName = sname;	if(newName == "")	{		newName = "s_" + scntr;		scntr++;	}	else if(undefined == newName)	{		newName = "s_" + scntr;		scntr++;	}	else if(__CheckIfDoubleBytePresent(newName))	{		newName = "s_" + scntr;		scntr++;			}	for( x in swatchNameArr)		{			if(swatchNameArr[x] == newName)		{			newName= newName + "_" + scntr;			scntr++;		}	}	swatchNameArr.push(newName);	return newName;}function __parseActiveButton(dom){	var CSSActive = "";	swatchCSSArr['ui_active'] = "";	swatchCSSArr['ui_button_active_link_inherit'] = "";	var activeLayer = dom.frames[0].topLayers[2];	//The index assigned as 2. 		if((activeLayer) && ((activeLayer.name)=="active"))	{		var lName = activeLayer.name;		var cnt = 0;		var sel = activeLayer.elemsandsublayers;		for(cnt = sel.length - 1 ; cnt >= 0 ; cnt--)			{					if(("[object Text]"==(sel[cnt].toString())) && (undefined == (sel[cnt].textRuns.textRuns)))				{					continue;				}				else				{					CSSActive += __parseActive(sel[cnt],lName);				}			}		if((swatchCSSArr['ui_button_active_link_inherit']) != "")			CSSActive += swatchCSSArr['ui_button_active_link_inherit'];		return CSSActive;			}	else	//If user has added some more layers below the active layer	{		var cnt = 0;		var CSSactive = "";		var frames = dom.frames;				var x=0;		//Find the active layer		for(x = 0 ; x < frames[0].topLayers.length - 1 ; x++)	//myFrames[0].topLayers.length gives the number of layers along with the state associated with it(frame and layer intersection)		{				//Iterating through the layers			var tpLayer = frames[0].topLayers[x];								var elemns = tpLayer.elemsandsublayers;	//Get the elements and sublayers in this layer(if there is a sublayer then its ignored)				if(tpLayer.locked) //For locked layers				continue;			else if("active" == tpLayer.name)				{   				for(cnt = elemns.length - 1 ; cnt >= 0 ; cnt--)				{						if(("[object Text]"==(elemns[cnt].toString())) && (undefined == (elemns[cnt].textRuns.textRuns)))					{						continue;					}					else					{						CSSActive += __parseActive(elemns[cnt],tpLayer.name);					}				}				if((swatchCSSArr['ui_button_active_link_inherit']) != "")					CSSActive += swatchCSSArr['ui_button_active_link_inherit'];				return CSSActive;			}			else				continue;		}	}		return "";}function __parseActive(element,layerName){		if(layerName=="active") 	{		if((element.toString()== "[object RectanglePrimitive]") && (element.name== "active-ui"))		{			if(check_active==false)			{				check_active=true;				swatchCSSArr['ui_active'] += "\.ui-btn-active {\n \tcursor : pointer;\n";				swatchCSSArr['ui_active'] += getValue(element,1);				swatchCSSArr['ui_active_forIcon'] = "";				swatchCSSArr['ui_active_forIcon'] += getValue(element,1);				return "";										}			else			{				swatchCSSArr['ui_active'] += getValue(element,1);				swatchCSSArr['ui_active'] += "\n}\n";				swatchCSSArr['ui_active_forIcon'] = "";				swatchCSSArr['ui_active_forIcon'] += getValue(element,1);				return swatchCSSArr['ui_active'];			}				}	//Writing properties for ui-active text		else if((element.toString()== "[object Text]") && (element.name== "active-text"))		{			var withoutMSfilter = "";			if(check_active==false)			{				check_active=true;				swatchCSSArr['ui_active'] += "\.ui-btn-active {\n \tcursor : pointer;\n";				swatchCSSArr['ui_active'] += __getFontName(element);				withoutMSfilter += getValue(element,1);				swatchCSSArr['ui_active'] += withoutMSfilter;								if(withoutMSfilter != "")				{					swatchCSSArr['ui_button_active_link_inherit'] += "\n.ui-btn-active a.ui-link {\n";					swatchCSSArr['ui_button_active_link_inherit'] += withoutMSfilter;					swatchCSSArr['ui_button_active_link_inherit'] += "\n}\n";				}								return "";										}			else			{				swatchCSSArr['ui_active'] += __getFontName(element);				withoutMSfilter += getValue(element,1);				swatchCSSArr['ui_active'] += withoutMSfilter;				swatchCSSArr['ui_active'] += "\n}\n";				//Active link inherit takes the properties of the active text				if(withoutMSfilter != "")				{					swatchCSSArr['ui_button_active_link_inherit'] += "\n.ui-btn-active a.ui-link {\n";					swatchCSSArr['ui_button_active_link_inherit'] += withoutMSfilter;					swatchCSSArr['ui_button_active_link_inherit'] += "\n}\n";				}				return swatchCSSArr['ui_active'];			}				}		else			return "";	}	else		return "";}function __parseGlobalIconDisc(dom){	var iconDiscLayer = dom.frames[0].topLayers[4];//The index assigned as 4 as the global icon disc layer is present in layer 4 by default. 	if((iconDiscLayer) && ((iconDiscLayer.name)== "icon_disc"))	{		var lName = iconDiscLayer.name;		var sel = iconDiscLayer.elemsandsublayers;		var cnt = 0;		for(cnt = sel.length - 1 ; cnt >= 0 ; cnt--)			{					if(("[object Text]"==(sel[cnt].toString())) && (undefined == (sel[cnt].textRuns.textRuns)))				{					continue;				}				else				{					CSSGlobalIconDisc += __parseIconDiscforjQuery(sel[cnt],lName);				}			}		return ;			}	else	//If user has added some more layers below the active layer	{		var cnt = 0;		var frames = fw.getDocumentDOM().frames;				var x;		x=0;		//Find the active layer		for(x = 0 ; x < frames[0].topLayers.length - 1 ; x++)	//myFrames[0].topLayers.length gives the number of layers along with the state associated with it(frame and layer intersection)		{				//Iterating through the layers			var tpLayer = frames[0].topLayers[x];								var elemns = tpLayer.elemsandsublayers;	//Get the elements and sublayers in this layer(if there is a sublayer then its ignored)				if(tpLayer.locked) //For locked layers				continue;			else if("icon_disc" == tpLayer.name)				{   				for(cnt = elemns.length - 1 ; cnt >= 0 ; cnt--)				{						if(("[object Text]"==(elemns[cnt].toString())) && (undefined == (elemns[cnt].textRuns.textRuns)))					{						continue;					}					else					{						CSSGlobalIconDisc += __parseIconDiscforjQuery(elemns[cnt],tpLayer.name);					}				}				return;			}			else				continue;		}	}		return;}function __parseIconDiscforjQuery(element,layerName){	var iconCSS = "";	if(layerName=="icon_disc") 	{		if((element.toString()== "[object Path]") && (element.name== "icon_background"))		{			iconCSS += getValue(element,1);			return iconCSS;		}		else			return "";	}	else		return "";}function __parseGlobalShadowProperties(dom){	var CSSGlobalShadow = "";	var boxShadowLayer = dom.frames[0].topLayers[6];//The index assigned as 6 as the global box shadow layer is present in layer 3 by default. 	if((boxShadowLayer) && ((boxShadowLayer.name) == "global_shadow"))	{		var lName = boxShadowLayer.name;		var sel = boxShadowLayer.elemsandsublayers;		var cnt = 0;		for(cnt = sel.length - 1 ; cnt >= 0 ; cnt--)			{					if(("[object Text]"==(sel[cnt].toString())) && (undefined == (sel[cnt].textRuns.textRuns)))				{					continue;				}				else				{					CSSGlobalShadow += __parseShadowforjQuery(sel[cnt],lName);				}			}		return CSSGlobalShadow;			}	else	//If user has added some more layers below the active layer	{		var cnt = 0;		var CSSGlobalShadow = "";		var frames = fw.getDocumentDOM().frames;				var x;		x=0;		//Find the active layer		for(x = 0 ; x < frames[0].topLayers.length - 1 ; x++)	//myFrames[0].topLayers.length gives the number of layers along with the state associated with it(frame and layer intersection)		{				//Iterating through the layers			var tpLayer = frames[0].topLayers[x];								var elemns = tpLayer.elemsandsublayers;	//Get the elements and sublayers in this layer(if there is a sublayer then its ignored)				if(tpLayer.locked) //For locked layers				continue;			else if("global_shadow" == tpLayer.name)				{   				for(cnt = elemns.length - 1 ; cnt >= 0 ; cnt--)				{						if(("[object Text]"==(elemns[cnt].toString())) && (undefined == (elemns[cnt].textRuns.textRuns)))					{						continue;					}					else					{						CSSGlobalShadow += __parseShadowforjQuery(elemns[cnt],tpLayer.name);					}				}				return CSSGlobalShadow;			}			else				continue;		}	}		return "";}function __parseShadowforjQuery(element,layerName){	var shadowCSS = "";	if(layerName=="global_shadow") 	{		if((element.toString()== "[object RectanglePrimitive]") && (element.name== "shadow_global"))		{						shadowCSS += "\n.ui-shadow {\n";			var EffectsList = element.effectList;			var boxShadowValues = "";			if(EffectsList)			{				KnockOutCaseForShadows = __CheckForKnockOutShadow(EffectsList);				boxShadowValues += __ExtractEffectsListProperties(EffectsList, KnockOutCaseForShadows, "Artwork", "box-shadow:");			}			boxShadowValues = __StripXMLForJQuery(boxShadowValues);			boxShadowValues = __IndentTheCode(boxShadowValues);			shadowCSS += boxShadowValues;			shadowCSS += "\n}\n";			return shadowCSS;		}		else			return "";	}	else		return "";}function __parseGlobalRadii(dom){	var CSSRadii = "";	var radiiLayer = dom.frames[0].topLayers[3];//The index assigned as 3 as the radii layer is present in layer 3 by default. 	if((radiiLayer) && ((radiiLayer.name)=="global-radii"))	{		var lName = radiiLayer.name;		var sel = radiiLayer.elemsandsublayers;		var cnt = 0;		for(cnt = sel.length - 1 ; cnt >= 0 ; cnt--)			{					if(("[object Text]"==(sel[cnt].toString())) && (undefined == (sel[cnt].textRuns.textRuns)))				{					continue;				}				else				{					CSSRadii += __parseRadii(sel[cnt],lName);				}			}		return CSSRadii;	}	else	//If user has added some more layers below the active layer	{		var cnt = 0;		var CSSRadii = "";		var frames = fw.getDocumentDOM().frames;				var x;		x=0;		//Find the active layer		for(x = 0 ; x < frames[0].topLayers.length - 1 ; x++)	//myFrames[0].topLayers.length gives the number of layers along with the state associated with it(frame and layer intersection)		{				//Iterating through the layers			var tpLayer = frames[0].topLayers[x];								var elemns = tpLayer.elemsandsublayers;	//Get the elements and sublayers in this layer(if there is a sublayer then its ignored)				if(tpLayer.locked) //For locked layers				continue;			else if("global-radii" == tpLayer.name)				{   				for(cnt = elemns.length - 1 ; cnt >= 0 ; cnt--)				{						if(("[object Text]"==(elemns[cnt].toString())) && (undefined == (elemns[cnt].textRuns.textRuns)))					{						continue;					}					else					{						CSSRadii += __parseRadii(elemns[cnt],tpLayer.name);					}				}				return CSSRadii;			}			else				continue;		}	}		return "";}function __parseRadii(element,layerName){	var radiiClass = "";	if(layerName=="global-radii") 	{		if((element.toString()== "[object RectanglePrimitive]") && (element.name== "group-radii"))		{			var computedGlobalCornerRadius = "";			computedGlobalCornerRadius = getValue(element);			computedGlobalCornerRadius = __getRadiusValue(computedGlobalCornerRadius);			radiiClass += "\.ui-corner-tl {\n";			radiiClass += "\t-moz-border-radius-topleft: ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n\t-webkit-border-top-left-radius: ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n\tborder-top-left-radius: ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n}\n";						radiiClass += "\.ui-corner-tr {\n";			radiiClass += "\t-moz-border-radius-topright: ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n\t-webkit-border-top-right-radius: ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n\tborder-top-right-radius: ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n}\n";						radiiClass += "\.ui-corner-bl {\n";			radiiClass += "\t-moz-border-radius-bottomleft: ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n\t-webkit-border-bottom-left-radius: ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n\tborder-bottom-left-radius: ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n}\n";						radiiClass += "\.ui-corner-br {\n";			radiiClass += "\t-moz-border-radius-bottomright: ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n\t-webkit-border-bottom-right-radius: ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n\tborder-bottom-right-radius:  ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n}\n";						radiiClass += "\.ui-corner-top {\n";			radiiClass += "\t-moz-border-radius-topleft: ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n\t-webkit-border-top-left-radius: ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n\tborder-top-left-radius:  ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n\t-moz-border-radius-topright:  ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n\t-webkit-border-top-right-radius:  ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n\tborder-top-right-radius:  ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n}\n";						radiiClass += "\.ui-corner-bottom {\n";			radiiClass += "\t-moz-border-radius-bottomleft: ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n\t-webkit-border-bottom-left-radius: ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n\tborder-bottom-left-radius: ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n\t-moz-border-radius-bottomright:  ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n\t-webkit-border-bottom-right-radius: ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n\tborder-bottom-right-radius: ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n}\n";						radiiClass += "\.ui-corner-right {\n";			radiiClass += "\t-moz-border-radius-topright: ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n\t-webkit-border-top-right-radius: ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n\tborder-top-right-radius: ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n\t-moz-border-radius-bottomright: ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n\t-webkit-border-bottom-right-radius: ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n\tborder-bottom-right-radius: ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n}\n";						radiiClass += "\.ui-corner-left {\n";			radiiClass += "\t-moz-border-radius-topleft: ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n\t-webkit-border-top-left-radius: ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n\tborder-top-left-radius: ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n\t-moz-border-radius-bottomleft: ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n\t-webkit-border-bottom-left-radius: ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n\tborder-bottom-left-radius: ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n}\n";						radiiClass += "\.ui-corner-all {\n";			radiiClass += "\t-moz-border-radius: ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n\t-webkit-border-radius: ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n\tborder-radius: ";			radiiClass += computedGlobalCornerRadius;			radiiClass += ";\n}\n";						radiiClass += "\.ui-corner-none {\n";			radiiClass += "\t-moz-border-radius: 0";			radiiClass += ";\n\t-webkit-border-radius: 0";			radiiClass += ";\n\tborder-radius: 0";			radiiClass += ";\n}\n";						return radiiClass;		}		else if((element.toString()== "[object RectanglePrimitive]") && (element.name== "button-radii"))		{			var computedGlobalButtonRadius = "";			computedGlobalButtonRadius = getValue(element,1);			computedGlobalButtonRadius = __getRadiusValue(computedGlobalButtonRadius);			radiiClass += "\.ui-btn-corner-tl {\n";			radiiClass += "\t-moz-border-radius-topleft: ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n\t-webkit-border-top-left-radius: ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n\tborder-top-left-radius: ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n}\n";						radiiClass += "\.ui-btn-corner-tr {\n";			radiiClass += "\t-moz-border-radius-topright: ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n\t-webkit-border-top-right-radius: ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n\tborder-top-right-radius: ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n}\n";						radiiClass += "\.ui-btn-corner-bl {\n";			radiiClass += "\t-moz-border-radius-bottomleft: ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n\t-webkit-border-bottom-left-radius: ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n\tborder-bottom-left-radius: ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n}\n";						radiiClass += "\.ui-btn-corner-br {\n";			radiiClass += "\t-moz-border-radius-bottomright: ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n\t-webkit-border-bottom-right-radius: ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n\tborder-bottom-right-radius:  ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n}\n";						radiiClass += "\.ui-btn-corner-top {\n";			radiiClass += "\t-moz-border-radius-topleft: ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n\t-webkit-border-top-left-radius: ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n\tborder-top-left-radius:  ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n\t-moz-border-radius-topright:  ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n\t-webkit-border-top-right-radius:  ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n\tborder-top-right-radius:  ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n}\n";						radiiClass += "\.ui-btn-corner-bottom {\n";			radiiClass += "\t-moz-border-radius-bottomleft: ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n\t-webkit-border-bottom-left-radius: ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n\tborder-bottom-left-radius: ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n\t-moz-border-radius-bottomright:  ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n\t-webkit-border-bottom-right-radius: ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n\tborder-bottom-right-radius: ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n}\n";						radiiClass += "\.ui-btn-corner-right {\n";			radiiClass += "\t-moz-border-radius-topright: ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n\t-webkit-border-top-right-radius: ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n\tborder-top-right-radius: ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n\t-moz-border-radius-bottomright: ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n\t-webkit-border-bottom-right-radius: ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n\tborder-bottom-right-radius: ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n}\n";						radiiClass += "\.ui-btn-corner-left {\n";			radiiClass += "\t-moz-border-radius-topleft: ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n\t-webkit-border-top-left-radius: ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n\tborder-top-left-radius: ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n\t-moz-border-radius-bottomleft: ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n\t-webkit-border-bottom-left-radius: ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n\tborder-bottom-left-radius: ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n}\n";						radiiClass += "\.ui-btn-corner-all {\n";			radiiClass += "\t-moz-border-radius: ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n\t-webkit-border-radius: ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n\tborder-radius: ";			radiiClass += computedGlobalButtonRadius;			radiiClass += ";\n}\n";						return radiiClass ;		}		else			return "";	}	else		return "";}function __getRadiusValue(CSSRoundnessValues){	var CSSVal = CSSRoundnessValues ;	CSSVal = CSSVal.replace(/\s+|\s+$/g, '');	var arrayOfProperties = new Array();	arrayOfProperties = CSSVal.split(";");	var roundnessValues = "";	var finalRoundnessVal = "";	var i =0;	for(i=0;i<arrayOfProperties.length;i++)	{		var singleProperty = arrayOfProperties[i];		if(singleProperty.match(/border-radius|-moz-border-radius|-webkit-border-radius/ig))		{			roundnessValues = singleProperty.split(":");			finalRoundnessVal = roundnessValues[1];			break;		}		else			continue;	}	if(finalRoundnessVal == "")	{		finalRoundnessVal = "0px";		return finalRoundnessVal;	}	else	{		return finalRoundnessVal;	}		return "";}//Call parseelement from herefunction __parseCSS(fwDOM, sname){	//Giving all global variables that are used for checking the default value	check_bar = false;	check_body = false;	check_buttonDown = false;	check_buttonUp = false;	check_buttonHover = false;	swatchCSSArr['ui_bar'] = "";	swatchCSSArr['ui_bar_link'] = "";	swatchCSSArr['ui_bar_link_inherit'] = "";		swatchCSSArr['ui_body'] = "";	swatchCSSArr['ui_body_link'] = "";	swatchCSSArr['ui_body_link_inherit'] = "";		swatchCSSArr['ui_button_up'] ="";	swatchCSSArr['ui_button_up_link_inherit'] ="";		swatchCSSArr['ui_button_down'] ="";	swatchCSSArr['ui_button_down_link_inherit'] ="";		swatchCSSArr['ui_button_hover'] = "";	swatchCSSArr['ui_button_hover_link_inherit'] = "";		swatchCSSArr['bar_fontFamily'] ="";	swatchCSSArr['body_fontFamily'] = "";		//css returned from each of the Fireworks objects	var css = "";		var dom= fwDOM;    var myFrames = dom.frames;	var j,cntk;						 	for(j = 0 ; j < myFrames[0].topLayers.length - 1 ; j++)	//myFrames[0].topLayers.length gives the number of layers along with the state associated with it(frame and layer intersection)	{			//Iterating through the layers		var topLayer = myFrames[0].topLayers[j];						var elems = topLayer.elemsandsublayers;	//Get the elements and sublayers in this layer(if there is a sublayer then its ignored)			if(topLayer.locked) //For locked layers			continue;		else		{   			for(cntk = elems.length - 1 ; cntk >= 0 ; cntk--)			{					if(("[object Text]"==(elems[cntk].toString())) && (undefined == (elems[cntk].textRuns.textRuns)))				{					continue;				}				else				{					css += __parseElement(topLayer.name,elems[cntk],dom,sname);									}			}		}	}		if(css != "")	{		css = "/*Custom Theme :" + sname + "\n-----------------------------------------------------------------------------------------------------------*/\n\n";		//Add ui-link and ui-link-inherit properties to CSS		css += swatchCSSArr['ui_bar'];				//If font family is missing/undefined/double byte replace it with a default font		if(swatchCSSArr['bar_fontFamily'] != "")			if(!(__CheckIfDoubleBytePresent(swatchCSSArr['bar_fontFamily'])))				if(undefined != swatchCSSArr['bar_fontFamily'])				{					css += ".ui-bar-"+sname +" ,\n" +						   ".ui-bar-" +sname +" input, \n"+						   ".ui-bar-" + sname +" select,\n"+ 						   ".ui-bar-" + sname +" textarea,\n" +						   ".ui-bar-" + sname +" button {\n\t font-family: " + swatchCSSArr['bar_fontFamily'] +";\n}\n";				}				css += swatchCSSArr['ui_bar_link_inherit'];		css += swatchCSSArr['ui_bar_link'];		css += swatchCSSArr['ui_body']				if(swatchCSSArr['body_fontFamily'] != "")			if(!(__CheckIfDoubleBytePresent(swatchCSSArr['body_fontFamily'])))				if(undefined != swatchCSSArr['body_fontFamily']) 				{					css += ".ui-body-"+sname +" ,\n" +						   ".ui-body-" +sname +" input, \n"+						   ".ui-body-" + sname +" select,\n"+ 						   ".ui-body-" + sname +" textarea,\n" +						   ".ui-body-" + sname +" button {\n\t font-family: " + swatchCSSArr['body_fontFamily'] +";\n}\n";				}				css += swatchCSSArr['ui_body_link_inherit'];		css += swatchCSSArr['ui_body_link'];				css += swatchCSSArr['ui_button_up']		css += swatchCSSArr['ui_button_up_link_inherit'];		css += swatchCSSArr['ui_button_hover']		css += swatchCSSArr['ui_button_hover_link_inherit'];		css += swatchCSSArr['ui_button_down'];		css += swatchCSSArr['ui_button_down_link_inherit'];					css += "\n";	}	else	{		swatchNameArr.pop(sname); //This has been added so that HTML is not generated for elements with no CSS	}	return css;}function __parseElement(lName,myElement,fwdom,sname){			var element = "";	var layerName = lName;		//Writing properties for ui-bar rectangle	if((layerName=="bar") && (myElement.toString()== "[object RectanglePrimitive]") && (myElement.name== "bar-ui"))	{			if(check_bar==false)		{						check_bar=true;			swatchCSSArr['ui_bar'] += "\.ui-bar-"+sname+" {\n";			swatchCSSArr['ui_bar'] += getValue(myElement,1);			return element;								}		else		{						swatchCSSArr['ui_bar'] += getValue(myElement,1);			swatchCSSArr['ui_bar'] += "\n}\n";			return swatchCSSArr['ui_bar'];		}			}	//Writing properties for ui-bar text	else if((layerName=="bar") && (myElement.toString()== "[object Text]") && (myElement.name== "bar-text"))	{		swatchCSSArr['bar_fontFamily'] = fw.getFamilyNameForPSFont(myElement.textRuns.textRuns[0].changedAttrs.face);		swatchCSSArr['bar_fontFamily'] = findAndReplaceInvalidFont(swatchCSSArr['bar_fontFamily']);		swatchCSSArr['bar_fontFamily'] = findAndReplaceWebSafeFonts(swatchCSSArr['bar_fontFamily']);				//For @font-face		fontFamilyArr.push(swatchCSSArr['bar_fontFamily']);			var withoutMSfilter = "";		if(check_bar==false)		{			check_bar=true;			swatchCSSArr['ui_bar'] += "\.ui-bar-"+sname+" {\n";			withoutMSfilter += getValue(myElement,1);			swatchCSSArr['ui_bar'] += withoutMSfilter;						//Check if you want to just take the color			if(withoutMSfilter != "")			{				swatchCSSArr['ui_bar_link_inherit'] = "\n.ui-bar-"+sname+ " " + ".ui-link-inherit {\n";				swatchCSSArr['ui_bar_link_inherit'] += withoutMSfilter;				swatchCSSArr['ui_bar_link_inherit'] += "\n}\n";				swatchCSSArr['ui_bar_link_inherit'] += "\n.ui-bar-"+sname+ " " + ".ui-link{\n\tcolor:  #7cc4e7;\n\tfont-weight: bold;\n}\n";				swatchCSSArr['ui_bar_link_inherit'] += "\n.ui-bar-"+sname+ " " + ".ui-link:hover{\n\tcolor: #2489CE;\n}\n";				swatchCSSArr['ui_bar_link_inherit'] += "\n.ui-bar-"+sname+ " " + ".ui-link:active{\n\tcolor: #2489CE;\n}\n";				swatchCSSArr['ui_bar_link_inherit'] += "\n.ui-bar-"+sname+ " " + ".ui-link:visited{\n\tcolor: #2489CE;\n}\n";			}			return element;		}		else		{			withoutMSfilter += getValue(myElement,1);			swatchCSSArr['ui_bar'] += withoutMSfilter;			swatchCSSArr['ui_bar'] += "\n}\n";						if(withoutMSfilter != "")			{				swatchCSSArr['ui_bar_link_inherit'] = "\n.ui-bar-"+sname+ " " + ".ui-link-inherit {\n";				swatchCSSArr['ui_bar_link_inherit'] += withoutMSfilter;				swatchCSSArr['ui_bar_link_inherit'] += "\n}\n";				swatchCSSArr['ui_bar_link_inherit'] += "\n.ui-bar-"+sname+ " " + ".ui-link{\n\tcolor:  #7cc4e7;\n\tfont-weight: bold;\n}\n";				swatchCSSArr['ui_bar_link_inherit'] += "\n.ui-bar-"+sname+ " " + ".ui-link:hover{\n\tcolor: #2489CE;\n}\n";				swatchCSSArr['ui_bar_link_inherit'] += "\n.ui-bar-"+sname+ " " + ".ui-link:active{\n\tcolor: #2489CE;\n}\n";				swatchCSSArr['ui_bar_link_inherit'] += "\n.ui-bar-"+sname+ " " + ".ui-link:visited{\n\tcolor: #2489CE;\n}\n";			}			return swatchCSSArr['ui_bar'];		}			}//Writing properties for ui-body rectangle	else if(layerName=="body")	{		if((myElement.toString()== "[object RectanglePrimitive]") && (myElement.name== "body-ui"))		{				if(check_body==false)			{				check_body=true;				swatchCSSArr['ui_body'] += "\.ui-body-"+sname+",\n.ui-dialog.ui-overlay-a {\n";				swatchCSSArr['ui_body'] += getValue(myElement,1);				return element;										}			else			{				swatchCSSArr['ui_body'] += getValue(myElement,1);				swatchCSSArr['ui_body'] += "\n}\n";				return swatchCSSArr['ui_body'];			}				}				//Writing properties for ui-body text		else if((myElement.toString()== "[object Text]") && (myElement.name== "body-text"))		{			swatchCSSArr['body_fontFamily'] = fw.getFamilyNameForPSFont(myElement.textRuns.textRuns[0].changedAttrs.face);			swatchCSSArr['body_fontFamily'] = findAndReplaceInvalidFont(swatchCSSArr['body_fontFamily']);			swatchCSSArr['body_fontFamily'] = findAndReplaceWebSafeFonts(swatchCSSArr['body_fontFamily']);			//For @font-face			fontFamilyArr.push(swatchCSSArr['body_fontFamily']);				var withoutMSfilter = "";			if(check_body==false)			{				check_body=true;				swatchCSSArr['ui_body'] += "\.ui-body-" + sname + ",\n.ui-dialog.ui-overlay-a {\n";				withoutMSfilter += getValue(myElement,1);				swatchCSSArr['ui_body'] += withoutMSfilter;								//Check if you want to just take the color				if(withoutMSfilter != "")				{					swatchCSSArr['ui_body_link_inherit'] = "\n.ui-body-"+sname+ " " + ".ui-link-inherit {\n";					swatchCSSArr['ui_body_link_inherit'] += withoutMSfilter;					swatchCSSArr['ui_body_link_inherit'] += "\n}\n";				}				return element;			}			else			{				withoutMSfilter += getValue(myElement,1);				swatchCSSArr['ui_body'] += withoutMSfilter;				swatchCSSArr['ui_body'] += "\n}\n";								//Check if you want to just take the color				if(withoutMSfilter != "")				{					swatchCSSArr['ui_body_link_inherit'] = "\n.ui-body-"+sname+ " " + ".ui-link-inherit {\n";					swatchCSSArr['ui_body_link_inherit'] += withoutMSfilter;					swatchCSSArr['ui_body_link_inherit'] += "\n}\n";				}				return swatchCSSArr['ui_body'];			}				}		else		{			swatchCSSArr['ui_body_link'] += __parseLinks(myElement,"body",sname);			return "";		}	}	else if((layerName=="button") && (myElement.toString()== "[object RectanglePrimitive]") && (myElement.name== "button-up-ui"))	{			if(check_buttonUp==false)		{						check_buttonUp=true;			swatchCSSArr['ui_button_up'] += "\.ui-btn-up-"+sname+" {\n";			swatchCSSArr['ui_button_up'] += getValue(myElement,1);			return element;					}		else		{			swatchCSSArr['ui_button_up'] += getValue(myElement,1);					swatchCSSArr['ui_button_up'] += "\n}\n";			return swatchCSSArr['ui_button_up'];		}	}					else if((layerName=="button") && (myElement.toString()== "[object Text]") && (myElement.name== "button-up-text"))	{		var withoutMSfilter = "";		if(check_buttonUp==false)		{			check_buttonUp=true;			swatchCSSArr['ui_button_up'] += "\.ui-btn-up-"+sname+" {\n";			swatchCSSArr['ui_button_up'] += __getFontName(myElement);			withoutMSfilter += getValue(myElement,1);			swatchCSSArr['ui_button_up'] += withoutMSfilter;						//Check if you want to just take the color			if(withoutMSfilter != "")			{				swatchCSSArr['ui_button_up_link_inherit'] = "\n.ui-btn-up-"+sname+ " " + "a.ui-link-inherit {\n";				swatchCSSArr['ui_button_up_link_inherit'] += withoutMSfilter;				swatchCSSArr['ui_button_up_link_inherit'] += "\n}\n";			}									return element;								}		else		{			swatchCSSArr['ui_button_up'] += __getFontName(myElement);			withoutMSfilter += getValue(myElement,1);			swatchCSSArr['ui_button_up'] += withoutMSfilter;			swatchCSSArr['ui_button_up'] += "\n}\n";						//Check if you want to just take the color			if(withoutMSfilter != "")			{				swatchCSSArr['ui_button_up_link_inherit'] = "\n.ui-btn-up-"+sname+ " " +  "a.ui-link-inherit {\n";				swatchCSSArr['ui_button_up_link_inherit'] += withoutMSfilter;				swatchCSSArr['ui_button_up_link_inherit'] += "\n}\n";			}						return swatchCSSArr['ui_button_up'];		}			}		else if((layerName=="button") && (myElement.toString()== "[object RectanglePrimitive]") && (myElement.name== "button-hover-ui"))	{			if(check_buttonHover==false)		{						check_buttonHover=true;			swatchCSSArr['ui_button_hover'] += "\.ui-btn-hover-"+sname+" {\n";			swatchCSSArr['ui_button_hover'] += getValue(myElement,1);			return element;					}		else		{						swatchCSSArr['ui_button_hover'] += getValue(myElement,1);			swatchCSSArr['ui_button_hover'] += "\n}\n";			return swatchCSSArr['ui_button_hover'];		}	}					else if((layerName=="button") && (myElement.toString()== "[object Text]") && (myElement.name== "button-hover-text"))	{		var withoutMSfilter = "";		if(check_buttonHover==false)		{						check_buttonHover=true;			swatchCSSArr['ui_button_hover'] += "\.ui-btn-hover-"+sname+" {\n";			swatchCSSArr['ui_button_hover'] += __getFontName(myElement);			withoutMSfilter += getValue(myElement,1);			swatchCSSArr['ui_button_hover'] += withoutMSfilter;						//Check if you want to just take the color			if(withoutMSfilter != "")			{				swatchCSSArr['ui_button_hover_link_inherit'] = "\n.ui-btn-hover-"+sname+ " "  + "a.ui-link-inherit {\n";				swatchCSSArr['ui_button_hover_link_inherit'] += withoutMSfilter;				swatchCSSArr['ui_button_hover_link_inherit'] += "\n}\n";			}												return element;									}		else		{			swatchCSSArr['ui_button_hover'] += __getFontName(myElement);			withoutMSfilter += getValue(myElement,1);			swatchCSSArr['ui_button_hover'] += withoutMSfilter;			swatchCSSArr['ui_button_hover'] += "\n}\n";						//Check if you want to just take the color			if(withoutMSfilter != "")			{				swatchCSSArr['ui_button_hover_link_inherit'] = "\n.ui-btn-hover-"+sname+ " " + "a.ui-link-inherit {\n";				swatchCSSArr['ui_button_hover_link_inherit'] += withoutMSfilter;				swatchCSSArr['ui_button_hover_link_inherit'] += "\n}\n";			}						return swatchCSSArr['ui_button_hover'];		}			}		else if((layerName=="button") && (myElement.toString()== "[object RectanglePrimitive]") && (myElement.name== "button-down-ui"))	{			if(check_buttonDown==false)		{						check_buttonDown=true;			swatchCSSArr['ui_button_down'] += "\.ui-btn-down-"+sname+" {\n";			swatchCSSArr['ui_button_down'] += getValue(myElement,1);				return element;					}		else		{			swatchCSSArr['ui_button_down'] += getValue(myElement,1);				swatchCSSArr['ui_button_down'] += "\n}\n";			return swatchCSSArr['ui_button_down'];		}	}					else if((layerName=="button") && (myElement.toString()== "[object Text]") && (myElement.name== "button-down-text"))	{		var withoutMSfilter = "";		if(check_buttonDown==false)		{						check_buttonDown=true;			swatchCSSArr['ui_button_down'] += "\.ui-btn-down-"+sname+" {\n";			swatchCSSArr['ui_button_down'] += __getFontName(myElement);			withoutMSfilter += getValue(myElement,1);			swatchCSSArr['ui_button_down'] += withoutMSfilter;						//Check if you want to just take the color			if(withoutMSfilter != "")			{				swatchCSSArr['ui_button_down_link_inherit'] = "\n.ui-btn-down-"+sname+ " "  + "a.ui-link-inherit {\n";				swatchCSSArr['ui_button_down_link_inherit'] += withoutMSfilter;				swatchCSSArr['ui_button_down_link_inherit'] += "\n}\n";			}									return element;											}		else		{			swatchCSSArr['ui_button_down'] += __getFontName(myElement);			withoutMSfilter += getValue(myElement,1);			swatchCSSArr['ui_button_down'] += withoutMSfilter;			swatchCSSArr['ui_button_down'] += "\n}\n";						//Check if you want to just take the color			if(withoutMSfilter != "")			{				swatchCSSArr['ui_button_down_link_inherit'] = "\n.ui-btn-down-"+sname+ " "  + "a.ui-link-inherit {\n";				swatchCSSArr['ui_button_down_link_inherit'] += withoutMSfilter;				swatchCSSArr['ui_button_down_link_inherit'] += "\n}\n";			}									return swatchCSSArr['ui_button_down'];		}			}	else	{			element += "";		return element;	}	}function __parseLinks(element,layerName,swatchName){	var linkCSS = "";	//if(layerName=="body") 	if((layerName=="body") || (layerName=="bar"))	{		if((element.toString()== "[object Text]") && (element.name== (layerName + "-link-hover")))		{			linkCSS += "\n.ui-" + layerName.toLowerCase() + "-" + swatchName + " .ui-link:hover{\n";			linkCSS += __getFontName(element);			linkCSS += getValue(element,1);			linkCSS += "\n}\n";			return linkCSS;		}		else if((element.toString()== "[object Text]") && (element.name== (layerName + "-link-active")))		{			linkCSS += "\n.ui-" + layerName.toLowerCase() + "-" + swatchName + " .ui-link:active{\n";			linkCSS += __getFontName(element);			linkCSS += getValue(element,1);			linkCSS += "\n}\n";			return linkCSS;		}		else if((element.toString()== "[object Text]") && (element.name== (layerName + "-link-visited")))		{			linkCSS += "\n.ui-" + layerName.toLowerCase() + "-" + swatchName + " .ui-link:visited{\n";			linkCSS += __getFontName(element);			linkCSS += getValue(element,1);			linkCSS += "\n}\n";			return linkCSS;		}		//Normal is used for ui-bar and ui-body along with font-weight = bold		else if((element.toString()== "[object Text]") && (element.name== (layerName + "-link-normal")))		{						linkCSS += "\n.ui-" + layerName.toLowerCase() + "-" + swatchName + " .ui-link{\n";			linkCSS += __getFontName(element);			linkCSS += getValue(element,1);			linkCSS += "\n}\n";			return linkCSS;		}		else			return "";	}	else		return "";}function __getFontName(element){	var fontName = "";	var fontNameCSS = "";	fontName = fw.getFamilyNameForPSFont(element.textRuns.textRuns[0].changedAttrs.face);	fontName = findAndReplaceInvalidFont(fontName);	fontName = findAndReplaceWebSafeFonts(fontName);	if(!(__CheckIfDoubleBytePresent(fontName)))	{		if(fontName != "")		{			if(fontName != undefined)			{				fontFamilyArr.push(fontName);					fontNameCSS = "\tfont-family: "+fontName + ";\n";				return fontNameCSS;			}		}	}		return "";}function findAndReplaceInvalidFont(fontName){	var replacedFont = fontName;	if((__CheckIfDoubleBytePresent(fontName)))	{		replacedFont = 'Helvetica, Arial, sans-serif';		invalidFont = true;	}	if(fontName == "")	{		replacedFont = 'Helvetica, Arial, sans-serif';		invalidFont = true;	}	if(fontName == undefined)	{		replacedFont = 'Helvetica, Arial, sans-serif';		invalidFont = true;	}	return replacedFont;}//For deleting font names with double byte charatersfunction __CheckIfDoubleBytePresent(font){  var ReturnFont = "";  for(var i = 0; i < font.length; i++)  {    if(font.charCodeAt(i) > 255)			return true;           }	return false;}//--------------------------------------------------------------------// FUNCTION://   findAndReplaceWebSafeFonts//// DESCRIPTION://   Checks and replaces the fallback font for the websafe fonts//	  // ARGUMENTS://   system font name//// RETURNS://   String containing websafe font with the appropriate fallback family names//--------------------------------------------------------------------function findAndReplaceWebSafeFonts(fontName){	var ffPatternArray = new Array(/verdana|geneva/i,/arial black|gadget/i,/arial|helvetica/i, /trebuchet ms|arial|helvetica/i,/times new roman|times/i,/georgia|times/i, /courier new|courier/i, /tahoma|geneva/i, /palantino|book antiqua/i, /lucida sans unicode| lucida grande/i, /ms serif | new york/i ,/lucida console|monaco/i, /comic sans ms/i);	var changedToWebSafe = fontName;	if(changedToWebSafe.match(ffPatternArray[0]))	{	        if(!changedToWebSafe.match("Verdana ") && !changedToWebSafe.match("Geneva "))	          {	            if(changedToWebSafe.match("Verdana"))					      changedToWebSafe = "Verdana, Geneva, sans-serif";					    else					      changedToWebSafe = "Geneva, Verdana, sans-serif";					  }	}	else if(changedToWebSafe.match(ffPatternArray[1]))	{  	        if(!changedToWebSafe.match("Arial Black ") && !changedToWebSafe.match("Gadget "))	          {	            if(changedToWebSafe.match("Arial Black"))					      changedToWebSafe = "Arial Black, Gadget, sans-serif";					    else					      changedToWebSafe = "Gadget, Arial Black, sans-serif";					  }	}	else if(changedToWebSafe.match(ffPatternArray[2]))	{		        if(!changedToWebSafe.match("Helvetica ") && !changedToWebSafe.match("Arial "))	          {	            if(changedToWebSafe.match("Helvetica"))					      changedToWebSafe = "Helvetica, Arial, sans-serif";					    else					      changedToWebSafe = "Arial, Helvetica, sans-serif";					  }	}	else if(changedToWebSafe.match(ffPatternArray[3]))	{		        if(!changedToWebSafe.match("Trebuchet MS ") && !changedToWebSafe.match("Arial ") && !changedToWebSafe.match("Helvetica "))	          {	            if(changedToWebSafe.match("Trebuchet MS"))					      changedToWebSafe = "Trebuchet MS, Arial, Helvetica, sans-serif";					    else if(changedToWebSafe.match("Arial"))					      changedToWebSafe = "Arial, Trebuchet MS, Helvetica, sans-serif";					    else					      changedToWebSafe = "Helvetica, Arial, Trebuchet MS, sans-serif";					  }	}	else if(changedToWebSafe.match(ffPatternArray[5]))	{		        if(!changedToWebSafe.match("Georgia ") && !changedToWebSafe.match("Times New Roman "))	          {	            if(changedToWebSafe.match("Georgia"))					      changedToWebSafe = "Georgia, Times New Roman, Times, serif";					    else					      changedToWebSafe = "Times New Roman, Georgia, Times, serif";					  }	}	else if(changedToWebSafe.match(ffPatternArray[4]))	{	      if(!changedToWebSafe.match("Times New Roman "))					changedToWebSafe = "Times New Roman, Times, serif";	}	else if(changedToWebSafe.match(ffPatternArray[6]))	{	          if(!changedToWebSafe.match("Courier New "))	          {	            changedToWebSafe = "Courier New, Courier, monospace";					  }	}	else if(changedToWebSafe.match(ffPatternArray[7]))	{		        if(!changedToWebSafe.match("Tahoma ") && !changedToWebSafe.match("Geneva "))	          {	            if(changedToWebSafe.match("Tahoma"))					      changedToWebSafe = "Tahoma, Geneva, sans-serif";					    else					      changedToWebSafe = "Geneva, Tahoma, sans-serif";					  }	}	else if(changedToWebSafe.match(ffPatternArray[8]))	{		        if(!changedToWebSafe.match("Palantino Linotype ") && !changedToWebSafe.match("Book Antiqua "))	          {	            if(changedToWebSafe.match("Palantino Linotype"))					      changedToWebSafe = "Palantino Linotype, Book Antiqua, Palatino, serif";					    else					      changedToWebSafe = "Book Antiqua, Palantino Linotype, Palatino, serif";					  }	}	else if(changedToWebSafe.match(ffPatternArray[9]))	{		        if(!changedToWebSafe.match("Lucida Sans Unicode ") && !changedToWebSafe.match("Lucida Grande "))	          {	            if(changedToWebSafe.match("Lucida Sans Unicode"))					      changedToWebSafe = "Lucida Sans Unicode, Lucida Grande, sans-serif";					    else					      changedToWebSafe = "Lucida Grande, Lucida Sans Unicode, sans-serif";					  }	}	else if(changedToWebSafe.match(ffPatternArray[10]))	{		        if(!changedToWebSafe.match("MS Serif ") && !changedToWebSafe.match("New York "))	          {	            if(changedToWebSafe.match("MS Serif"))					      changedToWebSafe = "MS Serif, New York, serif";					    else					      changedToWebSafe = "New York, MS Serif, serif";					  }	}	else if(changedToWebSafe.match(ffPatternArray[11]))	{		        if(!changedToWebSafe.match("Lucida Console ") && !changedToWebSafe.match("monaco "))	          {	            if(changedToWebSafe.match("Lucida Console"))					      changedToWebSafe = "Lucida Console,monaco, monospace";					    else					      changedToWebSafe = "monaco,Lucida Console, monospace";					  }	}	else if(changedToWebSafe.match(ffPatternArray[12]))	{		        if(!changedToWebSafe.match("Comic Sans MS ") && !changedToWebSafe.match("cursive "))	          {	            if(changedToWebSafe.match("Comic Sans MS"))					      changedToWebSafe = "Comic Sans MS, cursive";					    else					      changedToWebSafe = "cursive, Comic Sans MS";					  }  }	return changedToWebSafe;}function __fontFaceCSS(fontFaceArr){	fontFaceArr= __removeDuplicateFont(fontFaceArr);	var fontFace = "";	var i=0;	for(i in fontFaceArr)	{		if("" !=(fontFaceArr[i]))			if(undefined != fontFaceArr[i])			{				var fontNames = /Verdana, Geneva, sans-serif|Geneva, Verdana, sans-serif|Arial Black, Gadget, sans-serif|Gadget, Arial Black, sans-serif|Helvetica, Arial, sans-serif|Arial, Helvetica, sans-serif|Trebuchet MS, Arial, Helvetica, sans-serif|Arial, Trebuchet MS, Helvetica, sans-serif|Helvetica, Arial, Trebuchet MS, sans-serif|Georgia, Times New Roman, Times, serif|Times New Roman, Georgia, Times, serif|Times New Roman, Times, serif|Courier New, Courier, monospace|Tahoma, Geneva, sans-serif|Geneva, Tahoma, sans-serif|Palantino Linotype, Book Antiqua, Palatino, serif|Book Antiqua, Palantino Linotype, Palatino, serif|Lucida Sans Unicode, Lucida Grande, sans-serif|Lucida Grande, Lucida Sans Unicode, sans-serif| MS Serif, New York, serif|New York, MS Serif, serif|Lucida Console,monaco, monospace|monaco,Lucida Console, monospace|Comic Sans MS, cursive|cursive, Comic Sans MS/ig;				fontFamilyName = fontFaceArr[i];				if(fontFamilyName.match( fontNames) == null)				{				fontFace += "@font-face {\n\tfont-family: "+ fontFaceArr[i] +";\n";				fontFace += "\tsrc: local(\"" +fontFaceArr[i] +"\")\n}\n";				fontFace += "\n";				}			}	}		return fontFace;}/*function __removeDuplicateFont(fontArray){  var WithoutDupFont =new Array();	//Array without duplicate fonts  var i=j=0;  nextFont:for(i=0; i<fontArray.length;i++ )		   {  				for(j=0; j<WithoutDupFont.length;j++ )				{					if(WithoutDupFont[j]==fontArray[i]) 						continue nextFont;				}			    WithoutDupFont[WithoutDupFont.length] = fontArray[i];			}  return WithoutDupFont;}*/function __removeDuplicateFont(fontArray) {	var i;	var WithoutDupFont=[];	var obj={};	for (i=0;i<fontArray.length;i++) 	{		obj[fontArray[i]]=0;	}	for (i in obj) 	{		WithoutDupFont.push(i);	}	return WithoutDupFont;}try{	__main();} catch(FwErr){			if(FwErr == "Exit")		Files.deleteFileIfExisting(folder + "/" + imageFolder);	else		alert([FwErr, FwErr.lineNumber, FwErr.fileName].join("\n"));		}function __includeAdditionalCSSCode(){	var cssCode = "";	cssCode += "a.ui-link-inherit { \ntext-decoration: none !important; \n}\n.ui-btn-inner {\n\tborder-top: 1px solid 	#fff;\n\tborder-color: rgba(255,255,255,.3);\n}\n.ui-disabled {\n\topacity: .3;\n}\n.ui-disabled,\n.ui-disabled a {\n\tpointer-events: none;\n\tcursor: default;\n}\n.ui-checkbox .ui-icon {\n\t-moz-border-radius: 3px;\n\t-webkit-border-radius: 3px;\n\tborder-radius: 3px;\n}\n.ui-icon-checkbox-off,\n.ui-icon-radio-off {\n\tbackground-color: transparent;\n}\n.ui-icon-loading {\n\tbackground-image: url(images/ajax-loader.png);\n\twidth: 40px;\n\theight: 40px;\n\t-moz-border-radius:20px;\n\t-webkit-border-radius: 20px;\n\tborder-radius: 20px;\n\tbackground-size: 35px 35px;\n}\n.ui-corner-tl,\n.ui-corner-tr,\n.ui-corner-bl, \n.ui-corner-br,\n.ui-corner-top,\n.ui-corner-bottom, \n.ui-corner-right,\n.ui-corner-left,\n.ui-corner-all,\n.ui-btn-corner-tl,\n.ui-btn-corner-tr,\n.ui-btn-corner-bl,\n.ui-btn-corner-br,\n.ui-btn-corner-top,\n.ui-btn-corner-bottom, \n.ui-btn-corner-right,\n.ui-btn-corner-left,\n.ui-btn-corner-all {\n\t-webkit-background-clip: padding-box;\n\t-moz-background-clip: padding;\n\tbackground-clip: padding-box;\n}\n.ui-overlay {\n\tbackground: #666;\n\topacity: .5;\n\tfilter: Alpha(Opacity=50);\n\tposition: absolute;\n\twidth: 100%;\n\theight: 100%;\n}\n.ui-overlay-shadow {\n\t-moz-box-shadow: 0px 0px 12px rgba(0,0,0,.6);\n\t-webkit-box-shadow: 0px 0px 12px 		rgba(0,0,0,.6);\n\tbox-shadow: 0px 0px 12px	rgba(0,0,0,.6);\n}\n.ui-bar-a .ui-shadow,\n.ui-bar-b .ui-shadow ,\n.ui-bar-c .ui-shadow  {\n\t-moz-box-shadow: 0px 1px 0 rgba(255,255,255,.3);\n\t-webkit-box-shadow: 0px 1px 0 rgba(255,255,255,.3);\n\tbox-shadow: 0px 1px 0 	rgba(255,255,255,.3);\n}\n.ui-shadow-inset {\n\t-moz-box-shadow: inset 0px 1px 4px rgba(0,0,0,.2);\n\t-webkit-box-shadow: inset 0px 1px 4px 	rgba(0,0,0,.2);\n\tbox-shadow: inset 0px 1px 4px rgba(0,0,0,.2);\n}\n.ui-icon-shadow {\n\t-moz-box-shadow: 0px 1px 0 rgba(255,255,255,.4);\n\t-webkit-box-shadow: 0px 1px 0 	rgba(255,255,255,.4);\n\tbox-shadow: 0px 1px 0 rgba(255,255,255,.4);\n}\n.ui-mobile-nosupport-boxshadow * {\n\t-moz-box-shadow: none !important;\n\t-webkit-box-shadow: none !important;\n\tbox-shadow: none !important;\n}\n.ui-mobile-nosupport-boxshadow .ui-focus {\n\toutline-width: 2px;\n}\n";	return cssCode;}//--------------------------------------------------------------------// FUNCTION://   getValue//// DESCRIPTION://   The main function that drives everything//// ARGUMENTS://   aucune//// RETURNS://   the XML string containing the mapped CSS Properties corresponding to the FW properties.//	 some of the CSS properties might be the subset of FW properties and viceversa//--------------------------------------------------------------------function getValue(ObjectReference, Dummy){   var xml = "<object>";if ('undefined' != typeof fw && null != fw.getDocumentDOM() ){		var currentSel = fw.selection;		//assume there is only one selection	if(ObjectReference == "[object Text]")	//Extract the css properties corresponding to the text object	{	  var TextSelection = ObjectReference;				{								// Check for text			if(typeof(TextSelection.textRuns) == 'undefined' || typeof(TextSelection.textRuns.textRuns) == 'undefined')			{				xml = "</object>";				return xml;			}			var curRun = TextSelection.textRuns.textRuns[0].changedAttrs;			if(typeof curRun.size == 'undefined')           //check for legacy text if legacy text is present then nothing is present on the DOM at node changedAttrs			  curRun = TextSelection.textRuns.initialAttrs;			{				var font = fw.getPlatformNameForPSFont(curRun.face);				if(__CheckIfDoubleBytePresent(font))					font = curRun.face;				var fontCSS = "font-family:"+font;				var faceName = curRun.face;				var fontXML = "";								var EffectsList = ObjectReference.effectList;				var KnockOutCaseForShadows = false;	  				if(EffectsList)					KnockOutCaseForShadows = __CheckForKnockOutShadow(EffectsList);				xml += __ExtractEffectsListProperties(EffectsList, KnockOutCaseForShadows, "Text", "text-shadow:", TextSelection);			}			{						  //xml += __ExtractOpacity(ObjectReference);     //extract the opacity				//xml += "\n\n";			}			{				//xml += __GetWidthHeightXML(fw.selection[0].width, fw.selection[0].height);			}			{        var matrix = ObjectReference.transform.matrix;        if(matrix[1] != 0 || matrix[2] != 0 || matrix[3] != 0 || matrix[5] != 0 )        {				  xml += __ExtractTransformMatrix(ObjectReference, -1, -1);   //extract the transform matrix          xml += "\n\n";        }			}						{				var FontFace = curRun.face;				var FontStyleItalic = FontFace.match('Italic') + FontFace.match('It');				var FontWeightBold = FontFace.match("Bold");				var FontWeightHeavy = FontFace.match("Heavy");				var FontWeightBlack = FontFace.match("Black");				var FontWeightSemibold = FontFace.match("Semibold");				var FontWeightExtraBold = FontFace.match("ExtraBold");				var FontStretchCondensed = FontFace.match('Cond');				var DemiSemiKeywordPresent = FontFace.match('Demi') + FontFace.match('Semi');        var ExtraKeywordPresent = FontFace.match('extra');        var ExpandedKeywordPresent = FontFace.match('expanded');        var UltraKeywordPresent = FontFace.match('ultra');				var FontWeight = "";				var FontStretch = "";								if(FontWeightBold)					FontWeight = "bold";									if(FontWeightSemibold)					FontWeight = "600";									if(FontWeightHeavy )					FontWeight = "800";									if(FontWeightBlack || FontWeightExtraBold)					FontWeight = "900";									if(FontStretchCondensed)				{					FontStretch = "condensed";          if(ExtraKeywordPresent)            FontStretch = "extra-condensed";          if(UltraKeywordPresent)            FontStretch = "ultra-condensed";          if(DemiSemiKeywordPresent)            FontStretch = "semi-condensed";				}				if(ExpandedKeywordPresent)				{					FontStretch = "expanded";          if(ExtraKeywordPresent)            FontStretch = "extra-expanded";          if(UltraKeywordPresent)            FontStretch = "ultra-expanded";          if(DemiSemiKeywordPresent)            FontStretch = "semi-expanded";				}				if(FontStyleItalic)                       //extract the font style property				{					xml += "<property id = 'FontStyle' >";					xml += "<string>";					xml += "Italic";					xml += "</string>";					xml += "</property>";					xml += "<property id = 'FontStyleCSS' >";					xml += "<string1>";					xml += "font-style:";					xml += "italic;";        	xml += "\n\n";					xml += "</string1>";					xml += "</property>";				}								if(FontWeight)				{					xml += "<property id = 'FontWeight' >";					xml += "<string>";					xml += FontWeight;					xml += "</string>";					xml += "</property>";										xml += "<property id = 'FontWeightCSS' >";					xml += "<string1>";					xml += "font-weight:";					xml += FontWeight;					xml += ";";	        xml += "\n\n";					xml += "</string1>";					xml += "</property>";				}								if(FontStretch)				{					xml += "<property id = 'FontStretch' >";					xml += "<string>";					xml += FontStretch;					xml += "</string>";					xml += "</property>";										xml += "<property id = 'FontStretchCSS' >";					xml += "<string1>";					xml += "font-stretch:";					xml += FontStretch;					xml += ";";	        xml += "\n\n";					xml += "</string1>";					xml += "</property>";				}			}			var sizeFloat = parseFloat(curRun.size.toString().replace(/pt/,"") );			var Resolution = fw.getDocumentDOM().resolution;  // TODO: this might have implications for tracking and other font properties too.			var ResolutionUnits = fw.getDocumentDOM().resolutionUnits;			if(ResolutionUnits.match("cm"))			{			  Resolution = Resolution / 28.3464567; // 1 square cm = 28.3464567 points			}			else			{			  Resolution = Resolution / 72; // 1sq inch = 72 points			}						var sizeInt = Math.round(sizeFloat * Resolution);			{				var sizeCSS = "font-size:"+sizeInt+"pt;";				xml += "<property id = 'fontsize' >";				xml += "<string>";				xml += sizeInt+" pt";				xml += "</string>";				xml += "</property>";										xml += "<property id = 'fontsizecss' >";				xml += "<string1>";				xml += sizeCSS;        xml += "\n\n";				xml += "</string1>";				xml += "</property>";			}			if (curRun.rangeKerning != 0)			{				var trackingPixInt = Math.round(curRun.rangeKerning/12 * sizeFloat);								var trackingCSS = "letter-spacing:"+ trackingPixInt + "pt;";								xml += "<property id = 'tracking' >";				xml += "<string>";				xml += (trackingPixInt+" pt");				xml += "</string>";				xml += "</property>";								xml += "<property id = 'trackingcss' >";				xml += "<string1>";				xml += trackingCSS;        xml += "\n\n";				xml += "</string1>";				xml += "</property>";			}			if (curRun.baselineShift != 0)			{				var baselineCSS = "baseline-shift:" + curRun.baselineShift + "px;";	//#shift{ position:relative;top:"+ baselinePixInt + "px; }								xml += "<property id = 'baseline' >";				xml += "<string>";				xml += (curRun.baselineShift+" px");				xml += "</string>";				xml += "</property>";									xml += "<property id = 'baselinecss' >";				xml += "<string1>";				xml += baselineCSS;        xml += "\n\n";				xml += "</string1>";				xml += "</property>";			}						if (curRun.bold && !FontWeight)			{				xml += "<property id = 'bold' >";				xml += "<string>";				xml += "true";				xml += "</string>";				xml += "</property>";				xml += "<property id = 'boldcss' >";				xml += "<string1>";				xml += "font-weight:bold;";        xml += "\n\n";				xml += "</string1>";				xml += "</property>";			}			if (curRun.italic && !FontStyleItalic)			{				xml += "<property id = 'italic' >";				xml += "<string>";				xml += "true";				xml += "</string>";				xml += "</property>";				xml += "<property id = 'italiccss' >";				xml += "<string1>";				xml += "font-style:italic;";        xml += "\n\n";				xml += "</string1>";				xml += "</property>";			}			if (curRun.underline)			{				xml += "<property id = 'underline' >";				xml += "<string>";				xml += "true";				xml += "</string>";				xml += "</property>";								xml += "<property id = 'underlinecss' >";				xml += "<string1>";				xml += "text-decoration:underline;";        xml += "\n\n";				xml += "</string1>";				xml += "</property>";			}			      if(TextSelection.pathAttributes && TextSelection.pathAttributes.brush)      {         var textStrokeXML = "";        var Opacity = Math.round((TextSelection.opacity/100) * 100)/100;        var textStrokeColor = "rgb(";        if(Opacity < 1)          textStrokeColor = "rgba(";      textStrokeColor += parseInt(TextSelection.pathAttributes.brushColor.substr(1,2), 16);      textStrokeColor += ",";      textStrokeColor += parseInt(TextSelection.pathAttributes.brushColor.substr(3,2), 16);      textStrokeColor += ",";      textStrokeColor += parseInt(TextSelection.pathAttributes.brushColor.substr(5,2), 16);      if(Opacity < 1)      {        textStrokeColor += ",";        textStrokeColor += Opacity;      }      textStrokeColor += ")";        xml += "<property id = 'TextStroke' >";		xml += "<string>";        textStrokeXML += TextSelection.pathAttributes.brush.diameter;        textStrokeXML += "px ";		if(KnockOutCaseForShadows == true || Opacity == 0)			textStrokeColor = "transparent";      textStrokeXML += textStrokeColor;		textStrokeXML += ";";		xml += textStrokeXML;        xml += "</string>";		xml += "</property>";				xml += "<property id = 'TextStrokeCSS' >";		xml += "<string1>";        xml += "-webkit-text-stroke:";        xml += textStrokeXML;        xml += "\n\n";        xml += "</string1>";				xml += "</property>";      }		else		{				  var EffectsList = TextSelection.effectList;		        for(var i = 0; EffectsList && i < EffectsList.effects.length; i++)      {        if(EffectsList.effects[i].EffectMoaID.match('{8eeadf50-9efe-11da-a7460800200c9a66}') && EffectsList.effects[i].EffectIsVisible)        {                           if(typeof(EffectsList.effects[i].stroke) != 'undefined')          {            var strokeProperty = EffectsList.effects[i].stroke.split("&");                               if(strokeProperty[0] == "1")            {              var textStrokeXML = "";              var BorderWidth = Math.round(strokeProperty[2]);              BorderWidth += "px ";              var BorderColor = __ParsePhotoshopLiveEffectsStrokeColor(strokeProperty, KnockOutCaseForShadows, TextSelection);              xml += "<property id = 'TextStroke' >";              xml += "<string>";              xml += BorderWidth + BorderColor;              xml += "</string>";              xml += "</property>";              xml += "<property id = 'TextStrokeCSS' >";              xml += "<string1>";              xml += "-webkit-text-stroke:";              xml += BorderWidth + BorderColor + ";";              xml += "\n\n";              xml += "</string1>";              xml += "</property>";            }          }        }      }      		}		      		if (curRun.fillColor != "#000000" || KnockOutCaseForShadows || ObjectReference.opacity < 100)		{		  var Opacity = Math.round((ObjectReference.opacity/100) * 100)/100;      var fillColorCSS = "rgb(";      if(Opacity < 1)        fillColorCSS = "rgba(";      fillColorCSS += parseInt(curRun.fillColor.substr(1,2), 16);      fillColorCSS += ",";      fillColorCSS += parseInt(curRun.fillColor.substr(3,2), 16);      fillColorCSS += ",";      fillColorCSS += parseInt(curRun.fillColor.substr(5,2), 16);      if(Opacity < 1)      {        fillColorCSS += ",";        fillColorCSS += Opacity;      }      fillColorCSS += ")";				xml += "<property id = 'color' >";			xml += "<string>";			var color = "";			if(KnockOutCaseForShadows || curRun.fillColor.substr(7,2) == "00" || Opacity == 0)				color += "transparent";			else				color += fillColorCSS;			xml += color;			xml += "</string>";			xml += "</property>";			xml += "<property id = 'colorcss' >";			xml += "<string1>";			xml += "color:";			xml += color;			xml += ";";			xml += "\n\n";			xml += "</string1>";			xml += "</property>";		}			if (curRun.leading) // Take care of px case too		{			var lineHeightPix;			if(curRun.leadingMode.match('exact'))			{				lineHeightPix = Math.round(curRun.leading) + "px";			}						else			{				lineHeightPix = Math.round(curRun.leading * 100.0) + "%"; // / sizeFloat;			}						var lineHeightCSS = "line-height:"+ lineHeightPix;			xml += "<property id = 'leading' >";			xml += "<string>";			xml += lineHeightPix;			xml += "</string>";			xml += "</property>";			xml += "<property id = 'leadingcss' >";			xml += "<string1>";			xml += "line-height:";			xml += lineHeightPix;			xml += ";";			xml += "\n\n";			xml += "</string1>";			xml += "</property>";		}				if (curRun.alignment)		{			xml += "<property id = 'alignment' >";			xml += "<string>";			xml += curRun.alignment;			xml += "</string>";			xml += "</property>";			xml += "<property id = 'alignmentcss' >";			xml += "<string1>";			xml += "text-align:" + curRun.alignment + ";";			xml += "\n\n";			xml += "</string1>";			xml += "</property>";		}		if (curRun.paragraphIndent != 0)		{			xml += "<property id = 'indent' >";			xml += "<string>";			xml += curRun.paragraphIndent;			xml += "</string>";			xml += "</property>";			xml += "<property id = 'indentcss' >";			xml += "<string1>";			xml += "text-indent:" + curRun.paragraphIndent + ";";			xml += "\n\n";			xml += "</string1>";			xml += "</property>";		}		if (curRun.paragraphSpacingBefore)		{			xml += "<property id = 'margintop' >";			xml += "<string>";			xml += curRun.paragraphSpacingBefore;			xml += "px";			xml += "</string>";			xml += "</property>";			xml += "<property id = 'margintopcss' >";			xml += "<string1>";			xml += "padding-top:" + curRun.paragraphSpacingBefore + "px;";			xml += "\n\n";			xml += "</string1>";			xml += "</property>";		}					if (curRun.paragraphSpacingAfter)		{			xml += "<property id = 'marginbottom' >";			xml += "<string>";			xml += curRun.paragraphSpacingAfter;			xml += "px";			xml += "</string>";			xml += "</property>";			xml += "<property id = 'marginbottomcss' >";			xml += "<string1>";			xml += "padding-bottom:" + curRun.paragraphSpacingAfter + "px;";			xml += "\n\n";			xml += "</string1>";			xml += "</property>";		}		}				xml += "<property id = 'Zoom' >";		xml += "<string>";		xml += "zoom:1;";		xml += "\n\n";		xml += "</string>";		xml += "</property>";			}		var currentGradientSel = ObjectReference;	var SmartShapeMode = false;	var IsAutoShapeRectangle = 1;	if(currentGradientSel == "[object Path]" && currentGradientSel.elements == 'undefined')	{	 	 xml += __parsePath(currentGradientSel);	 return xml;	}	else if(currentGradientSel == "[object CompoundShape]")	{		currentGradientSel = currentGradientSel.resultantPath;		xml += __parsePath(currentGradientSel);				return xml;	}	if(ObjectReference == "[object Group]" || ObjectReference == "[object Path]")	{				if(currentGradientSel.elements)	  	currentGradientSel = currentGradientSel.elements[0];	  if(currentGradientSel.contours)	  {		  IsAutoShapeRectangle = __CheckIfRectangleAutoShape(currentGradientSel.contours[0].nodes);		  SmartShapeMode = true;		}	}	if(currentGradientSel != "[object Text]")	{			  var EffectsList = ObjectReference.effectList;	  var TransformMatrix = [1,0,0,0,1,0,0,0,1];			  var KnockOutCaseForShadows = false;	  var PSLiveEffectsObject = 0;	  if(EffectsList)	  {	  	  KnockOutCaseForShadows = __CheckForKnockOutShadow(EffectsList);		  PSLiveEffectsObject = __GetPSLiveEffectsObject(EffectsList);	  }				if (currentGradientSel.pathAttributes)			{								var SelectedRectTop = 0;				var SelectedRectBottom = 0;				var SelectedRectLeft = 0;				var SelectedRectRight = 0;				var width = 0;				var height = 0;				var RadialSizeConstant = "";				var ProcessEllipseGradient = true;				var ProcessRadialGradient = true;				var ProcessLinearGradient = true;			 	var ProcessOperaLinearGradient = true;				var ChooseSideForEllipse = "ellipse closest-side";        var FirstOpacityStopNotToBeIgnored = 0;				        if(SmartShapeMode == false)        {          TransformMatrix = currentGradientSel.transform.matrix;          if(TransformMatrix[1] != 0 || TransformMatrix[2] != 0 || TransformMatrix[3] != 0 || TransformMatrix[5] != 0)          {  					  SelectedRectTop = currentGradientSel.originalSides.top;				    SelectedRectBottom = currentGradientSel.originalSides.bottom;				    SelectedRectLeft = currentGradientSel.originalSides.left;				    SelectedRectRight = currentGradientSel.originalSides.right;          }          else          {  						var pt1 = new Object();						var pt2 = new Object();												pt1.x = currentGradientSel.originalSides.left;						pt1.y = currentGradientSel.originalSides.top;		        pt2.x = currentGradientSel.originalSides.right;						pt2.y = currentGradientSel.originalSides.bottom;             SelectedRectTop = __ComputeTransformPointY(pt1, TransformMatrix);             SelectedRectBottom = __ComputeTransformPointY(pt2, TransformMatrix);             SelectedRectLeft = __ComputeTransformPointX(pt1, TransformMatrix);             SelectedRectRight = __ComputeTransformPointX(pt2, TransformMatrix);          }			  	  width = SelectedRectRight - SelectedRectLeft;			    height = SelectedRectBottom - SelectedRectTop;				}				else if(SmartShapeMode && IsAutoShapeRectangle != 3)				{				  var Nodes = currentGradientSel.contours[0].nodes;				  SelectedRectTop = Nodes[1].y;					SelectedRectBottom = Nodes[6].y;					SelectedRectLeft = Nodes[0].x;					SelectedRectRight = Nodes[3].x;									  width = Nodes[3].x - Nodes[0].x;				  height = Nodes[6].y - Nodes[1].y;				}		if(currentGradientSel.pathAttributes.fill == null || KnockOutCaseForShadows)	//If there is no fill then the background is transparent		{			xml += "<property id = 'BGColor' >";			xml += "<string>";			xml += "transparent";						xml	+= "</string>"			xml += "</property>";			xml += "<property id = 'BGColorCSS' >";			xml += "<string1>";			xml += "background-color:";			xml += "transparent";						xml += ";";			xml += "\n\n";			xml	+= "</string1>"			xml += "</property>";		}//		if(SmartShapeMode)//	        xml += __ExtractOpacity(ObjectReference);//	    else//	        xml += __ExtractOpacity(currentGradientSel);		if(currentGradientSel.pathAttributes.brush)		{						xml += __ExtractBrushProperties(currentGradientSel, KnockOutCaseForShadows);		}		else		{				  var EffectsList = currentGradientSel.effectList;		        for(var i = 0; EffectsList && i < EffectsList.effects.length; i++)      {        if(EffectsList.effects[i].EffectMoaID.match('{8eeadf50-9efe-11da-a7460800200c9a66}') && EffectsList.effects[i].EffectIsVisible)        {          if(typeof(EffectsList.effects[i].stroke) != 'undefined')          {          	var strokeProperty = EffectsList.effects[i].stroke.split("&");          	if(strokeProperty[0] == "1")          	{            	xml += __ParsePhotoshopLiveEffectsStroke(strokeProperty, KnockOutCaseForShadows, currentGradientSel);          	}		  }        }      }      		}        if(SmartShapeMode == false)        {  				var BorderRadius = "";				  var RoundnessType = currentGradientSel.mode;				  var isPercentage = RoundnessType.match('percentage');				  var isExact = RoundnessType.match('exact');				  var styleName = "";          var brushName = "";				  if(currentGradientSel.pathAttributes.brush)          {  				    styleName = currentGradientSel.pathAttributes.brush.category;            brushName = currentGradientSel.pathAttributes.brush.name;          }  				var ShouldWeAdjustTheBoundary = false;           if(styleName.match(/pencil/i) || styleName.match(/basic/i))           {            if(brushName.match(/rounded/i) || brushName.match(/pixel/i))              ShouldWeAdjustTheBoundary = true;           }					if(currentGradientSel.roundness > 0 || (currentGradientSel.pathAttributes.brush && currentGradientSel.pathAttributes.brush.diameter > 0 && !(currentGradientSel.pathAttributes.brushPlacement == "inside" && currentGradientSel.roundness == 0)&& ShouldWeAdjustTheBoundary))					{		        xml += "<property id = 'BorderRadius' >";						xml += "<string>";						if(isPercentage)						{							if(width < height)								BorderRadius = Math.round(width/2 * currentGradientSel.roundness);							else								BorderRadius = Math.round(height/2 * currentGradientSel.roundness);													}						else if(isExact)						{							BorderRadius = Math.round(currentGradientSel.roundness);						}            var AdjustedBorder = __AdjustBorderRadiusAccordingToBrushPlacement(currentGradientSel, BorderRadius);            var diff = AdjustedBorder - BorderRadius;            var FirefoxOlderVersions = 0;            if(isPercentage)					  {					    FirefoxOlderVersions = Math.round((AdjustedBorder/(width + 2 * diff)) * 100) + "%";              BorderRadius  = __BorderRadiusInPercentage(width + 2 * diff, height + 2 * diff, AdjustedBorder);            }            else            {              BorderRadius = Math.floor(AdjustedBorder);              BorderRadius += "px";              FirefoxOlderVersions = BorderRadius;            }						xml += BorderRadius;						xml += "</string>";						xml += "</property>";										xml += "<property id = 'BorderRadiusCSS' >";						xml += "<string1>";            xml +=  "/* Firefox v1.0+ */\n";						xml += "-moz-border-radius:";						xml += FirefoxOlderVersions;						xml += ";";						xml += "\n";            xml +=  "/* Safari v3.0+ and by Chrome v0.2+ */\n";						xml += "-webkit-border-radius:";						xml += BorderRadius;						xml += ";";						xml += "\n";            xml +=  "/* Firefox v4.0+ , Safari v5.0+ , Chrome v4.0+ , Opera v10.5+  and by IE v9.0+ */\n";						xml += "border-radius:";						xml += BorderRadius;						xml += ";";						xml += "\n\n";						xml += "</string1>";						xml += "</property>";					}				}        else if(IsAutoShapeRectangle == 1 )        {				  var styleName = "";          var brushName = "";				  if(currentGradientSel.pathAttributes.brush)          {  				    styleName = currentGradientSel.pathAttributes.brush.category;            brushName = currentGradientSel.pathAttributes.brush.name;          }  				var ShouldWeAdjustTheBoundary = false;           if(styleName.match(/pencil/i) || styleName.match(/basic/i))           {            if(brushName.match(/rounded/i) || brushName.match(/pixel/i))              ShouldWeAdjustTheBoundary = true;           }                  var Nodes = currentGradientSel.contours[0].nodes;          xml += "<property id = 'BorderRadius' >";  				xml += "<string>";					var BorderRadius = __GetCornerRadius(Nodes[1], Nodes[0]);          if(ShouldWeAdjustTheBoundary)            BorderRadius = __AdjustBorderRadiusAccordingToBrushPlacement(currentGradientSel, BorderRadius);          BorderRadius += "px ";					if(__GetCornerRadius(Nodes[1], Nodes[0]) != __GetCornerRadius(Nodes[3], Nodes[2]) || 						 __GetCornerRadius(Nodes[1], Nodes[0]) != __GetCornerRadius(Nodes[4], Nodes[5]) ||						 __GetCornerRadius(Nodes[1], Nodes[0]) != __GetCornerRadius(Nodes[6], Nodes[7]))					{						if(ShouldWeAdjustTheBoundary)              BorderRadius += __AdjustBorderRadiusAccordingToBrushPlacement(currentGradientSel, __GetCornerRadius(Nodes[3], Nodes[2]));            else              BorderRadius += __GetCornerRadius(Nodes[3], Nodes[2]);		        BorderRadius += "px ";						if(ShouldWeAdjustTheBoundary)              BorderRadius += __AdjustBorderRadiusAccordingToBrushPlacement(currentGradientSel, __GetCornerRadius(Nodes[4], Nodes[5]));             else              BorderRadius += __GetCornerRadius(Nodes[4], Nodes[5]);		        BorderRadius += "px ";            if(ShouldWeAdjustTheBoundary)              BorderRadius += __AdjustBorderRadiusAccordingToBrushPlacement(currentGradientSel, __GetCornerRadius(Nodes[6], Nodes[7]));            else              BorderRadius += __GetCornerRadius(Nodes[6], Nodes[7]);		        BorderRadius += "px";					}					else if(__GetCornerRadius(Nodes[1], Nodes[0]) == 0)						BorderRadius = "";                    xml += BorderRadius;				  xml += "</string>";				  xml += "</property>";				  xml += "<property id = 'BorderRadiusCSS' >";				  xml += "<string1>";          xml +=  "/* Firefox v1.0+ */\n";				  xml += "-moz-border-radius:";				  xml += BorderRadius;				  xml += ";";				  xml += "\n";          xml +=  "/* Safari v3.0+ and by Chrome v0.2+ */\n";				  xml += "-webkit-border-radius:";				  xml += BorderRadius;				  xml += ";";				  xml += "\n";				  xml +=  "/* Firefox v4.0+ , Safari v5.0+ , Chrome v4.0+ , Opera v10.5+  and by IE v9.0+ */\n";				  xml += "border-radius:";				  xml += BorderRadius;				  xml += ";";				  xml += "\n\n";				  xml += "</string1>";				  xml += "</property>";        }				if(SmartShapeMode == false)        {          if(TransformMatrix[1] != 0 || TransformMatrix[2] != 0 || TransformMatrix[3] != 0 || TransformMatrix[5] != 0 )          {            xml += __ExtractTransformMatrix(currentGradientSel, SelectedRectLeft, SelectedRectTop); //transform matrix extraction          }        }				if(currentGradientSel.pathAttributes)				{					var GradNodes, OpacityNodes, Pt1 = 0, Pt2 = 0,Pt3 = 0, rotation, RelativePos1, RelativePos2,					percentage1, percentage2, RelativePos1Pt2, RelativePos2Pt2, percentage1Pt2, 					percentage2Pt2, radius;					if(IsAutoShapeRectangle < 3)					{            var Width = width, Height = height;            if(SmartShapeMode)            {              Width = fw.selection[0].width;              Height = fw.selection[0].height;            }            if(currentGradientSel.pathAttributes.brush)            {              if(currentGradientSel.pathAttributes.brushPlacement == "inside")              {                  if(Width >= 2 * currentGradientSel.pathAttributes.brush.diameter)                    Width -= 2 * currentGradientSel.pathAttributes.brush.diameter;                  if(Height >= 2 * currentGradientSel.pathAttributes.brush.diameter)                  Height -= 2 * currentGradientSel.pathAttributes.brush.diameter;              }              else if(currentGradientSel.pathAttributes.brushPlacement == "center")              {                  if(Width >= currentGradientSel.pathAttributes.brush.diameter)                    Width -= currentGradientSel.pathAttributes.brush.diameter;                  if(Height >= currentGradientSel.pathAttributes.brush.diameter)                    Height -= currentGradientSel.pathAttributes.brush.diameter;              }            }              						//xml += __GetWidthHeightXML(Width, Height);					}					if(currentGradientSel.pathAttributes.fill || currentGradientSel.pathAttributes.brush)	//shadow is applied only if there is a fill or a border					{						xml += __ExtractEffectsListProperties(EffectsList, KnockOutCaseForShadows, "Artwork", "box-shadow:", currentGradientSel);					}					if(currentGradientSel.pathAttributes.fill && currentGradientSel.pathAttributes.fill.gradient && KnockOutCaseForShadows == false)					{						 GradNodes = currentGradientSel.pathAttributes.fill.gradient.nodes;						 OpacityNodes = currentGradientSel.pathAttributes.fill.gradient.opacityNodes;											/****Pt1 is the origi-n of the gradient line****/						 Pt1 =  currentGradientSel.pathAttributes.fillHandle1;						/****Pt2 is the end of the gradient line****/						Pt2 =  currentGradientSel.pathAttributes.fillHandle2;						if(SmartShapeMode == false)						{							var pt1 = new Object();							var pt2 = new Object();													pt1.x = Pt1.x;							pt1.y = Pt1.y;		          pt2.x = Pt2.x;							pt2.y = Pt2.y;							if(TransformMatrix[1] != 0 || TransformMatrix[2] != 0 || TransformMatrix[3] != 0)							{     					 var InverseTransform = __CSSPropertiesComputeInverseByLUDecomposition(currentGradientSel.transform.matrix);                Pt1.x = __ComputeTransformPointX(pt1, InverseTransform);                Pt1.y = __ComputeTransformPointY(pt1, InverseTransform);                Pt2.x = __ComputeTransformPointX(pt2, InverseTransform);                Pt2.y = __ComputeTransformPointY(pt2, InverseTransform);							}  						}						 if(currentGradientSel.pathAttributes.fill.shape == "elliptical" && IsAutoShapeRectangle < 3)						 {							Pt3 = currentGradientSel.pathAttributes.fillHandle3;							var pt2 = new Object();								var pt3 = new Object();							pt2.x = Pt2.x - Pt1.x;	//vector Pt2							pt2.y = Pt2.y - Pt1.y;							pt3.x = Pt3.x - Pt1.x;	//vector Pt3							pt3.y = Pt3.y - Pt1.y;							var dotProduct = pt2.x * pt3.x + pt2.y * pt3.y;							var Pt2Magnitude = pt2.x * pt2.x + pt2.y * pt2.y;							var Pt3Magnitude = pt3.x * pt3.x + pt3.y * pt3.y;							var Denominator = Math.sqrt(Pt2Magnitude * Pt3Magnitude);							if(Math.abs(dotProduct/Denominator) < 0.3 )			//check if the fillhandles cross at 90 +-x degrees 							{								var realPt3 = Pt3;								var Side1 = Math.abs(SelectedRectTop - Pt1.y);								var Side2 = Math.abs(SelectedRectBottom - Pt1.y);								if(Math.abs(Pt2.y - Pt1.y) > 5)				//Check which handle is the vertical and which is horizontal								{									realPt3 = Pt2;								}																if(Side1  < Side2)			//fillhandle1(the centre of the ellipse) is closer to top								{									if(Math.abs(Side1 - Math.abs(realPt3.y - Pt1.y)) < Math.abs(Side2 - Math.abs(realPt3.y - Pt1.y))) // the vertical gradient line is closer to top									{											ChooseSideForEllipse = "ellipse closest-side";									}									else																							//the vertical gradient line is farther than top 									{											ChooseSideForEllipse = "ellipse farthest-side";									}								}																else	//(the centre of the ellipse) is closer to bottom (cases symmetric to the if case)								{									if(Math.abs(Side1 - Math.abs(realPt3.y - Pt1.y)) < Math.abs(Side2 - Math.abs(realPt3.y - Pt1.y))) 									{											ChooseSideForEllipse = "ellipse farthest-side";									}																		else									{										ChooseSideForEllipse = "ellipse closest-side";									}								}							}													 }             						 var TopX = SelectedRectLeft;						 var TopY = SelectedRectTop;						 var WidthForGrad = width;						 var HeightForGrad = height;             if(SmartShapeMode == false && (TransformMatrix[1] != 0 || TransformMatrix[2] != 0 || TransformMatrix[3] != 0))             {                TopX = currentGradientSel.originalSides.left;                TopY = currentGradientSel.originalSides.top;                WidthForGrad = currentGradientSel.originalSides.right - currentGradientSel.originalSides.left;                HeightForGrad = currentGradientSel.originalSides.bottom - currentGradientSel.originalSides.top;             }						 rotation = (Math.atan2(Pt2.y - Pt1.y , Pt2.x - Pt1.x) * 180)/3.14;						 						 RelativePos1 = Pt1.x - TopX;																			 RelativePos2 = Pt1.y - TopY;						 percentage1 = RelativePos1/WidthForGrad;						 percentage2 = RelativePos2/HeightForGrad;             						 if(currentGradientSel.pathAttributes.fill.shape == "radial")						 {						    radius = __GetRadius(Pt1, Pt2);						    RadialSizeConstant = __GetRadialSizeConstant(Pt1, Pt2, SelectedRectLeft, SelectedRectTop, SelectedRectRight, SelectedRectBottom, radius); 					   }													 RelativePos1Pt2 = Pt2.x - TopX;						 RelativePos2Pt2 = Pt2.y - TopY;						 percentage1Pt2 = RelativePos1Pt2/WidthForGrad;						 percentage2Pt2 = RelativePos2Pt2/HeightForGrad;					}					//gradient					  xml += __parseGradient(currentGradientSel, rotation, IsAutoShapeRectangle, ProcessLinearGradient,ProcessEllipseGradient, ProcessOperaLinearGradient, ProcessRadialGradient, RadialSizeConstant, ChooseSideForEllipse, GradNodes, OpacityNodes, percentage1, percentage2, percentage1Pt2, percentage2Pt2, KnockOutCaseForShadows, radius);				}			}	}}	xml += "</object>";  var CSSCode = __StripXMLForJQuery(xml);  CSSCode = __IndentTheCode(CSSCode);  return CSSCode;} //--------------------------------------------------------------------// FUNCTION://   __getGradientValue//// DESCRIPTION://   Function that interpolates the color value of a opacity stop and opacity value of a color stop//// ARGUMENTS://   gradNode-Array of gradient nodes//   position- position of the node to interpolate//   type - color/ opacity// RETURNS://   Interpolated RGBA value//--------------------------------------------------------------------function __getGradientValue(gradNode,position,type){	var length = gradNode.length;	var previousNode = gradNode[0];	var nextNode = gradNode[length - 1];	for(var cnt_i = 0 ; cnt_i < length ; cnt_i++)	{		if((gradNode[cnt_i].position < position) && (previousNode.position < gradNode[cnt_i].position))			previousNode = gradNode[cnt_i];		else if((gradNode[cnt_i].position > position) && (gradNode[cnt_i].position < nextNode.position))			nextNode = gradNode[cnt_i];		}		if(type == "Alpha")	{	// Equation to find opacity 		return __getCurrentValue(previousNode,nextNode,position,type);		}		else // type == "Color"	{				var Red = Math.round(__getCurrentValue(previousNode,nextNode,position,"Red"));			var Green = Math.round(__getCurrentValue(previousNode,nextNode,position,"Green"));			var Blue = Math.round(__getCurrentValue(previousNode,nextNode,position,"Blue"));			return Red + "," + Green + "," + Blue;	}} //--------------------------------------------------------------------// FUNCTION://   __getCurrentValue//// DESCRIPTION://   Extracts the rgb value from the color stops/ opacity stops//// ARGUMENTS://   //// RETURNS://   //--------------------------------------------------------------------function __getCurrentValue(prevNode,nextNode,position,type){	var p = position;	var p1 = prevNode.position;	var p2 = nextNode.position;	var a1,a2;	if(type == "Alpha")	{		a1 = a2 = 1;		if(prevNode.color.length > 7)			a1 = Math.round((parseInt((prevNode.color.substr(7,2)),16)/255) * 100)/100;					if(nextNode.color.length > 7)			a2 = Math.round((parseInt((nextNode.color.substr(7,2)),16)/255) * 100)/100;		if(a1 == a2) return a1;			}	else if(type == "Red") // type == "Color"	{		a1 = parseInt((prevNode.color.substr(1,2)),16);		a2 = parseInt((nextNode.color.substr(1,2)),16);				if(a1 == a2) return a1;	}	else if(type == "Green")	{		a1 = parseInt((prevNode.color.substr(3,2)),16);		a2 = parseInt((nextNode.color.substr(3,2)),16);		if(a1 == a2) return a1;		}	else if(type == "Blue")	{		a1 = parseInt((prevNode.color.substr(5,2)),16);		a2 = parseInt((nextNode.color.substr(5,2)),16);		if(a1 == a2) return a1;		}	var a = ((p - p1) * (a2 - a1))/(p2 - p1);	return Math.round((a1 + a) * 100)/100;} //--------------------------------------------------------------------// FUNCTION://   __ExtractTransformMatrix//// DESCRIPTION://   Extracts transform matrix xml//// ARGUMENTS://   element - The currently selected object//// RETURNS://   <type and description>//--------------------------------------------------------------------function __ExtractTransformMatrix(element, SelectedRectLeft, SelectedRectTop){  var tMatrix = element.transform.matrix;	var xml = "";  if(tMatrix && Math.abs(tMatrix[2]) <= 0.1 && Math.abs(tMatrix[5]) <= 0.1 && Math.abs(tMatrix[8] - 1) <= 0.1 && __CheckForIdentity(tMatrix) == false)  {	  var MatrixXML = "";		var TransformOriginXML = "";	  	  xml += "<property id = 'Transform' >";	  xml += "<string>";	  MatrixXML += "matrix(";	  MatrixXML += Math.round(tMatrix[0] * 100)/100;	  MatrixXML += ",";	  MatrixXML += Math.round(tMatrix[1] * 100)/100;	  MatrixXML += ",";	  MatrixXML += Math.round(tMatrix[3] * 100)/100;	  MatrixXML += ",";	  MatrixXML += Math.round(tMatrix[4] * 100)/100;	  MatrixXML += ",";		MatrixXML += "0,0";			    	  MatrixXML += ");";				TransformOriginXML += "center";		TransformOriginXML += ";";	  xml += MatrixXML;		xml += " \ntransform-origin:";		xml += TransformOriginXML;	  xml += "</string>";	  xml += "</property>";	    xml += "<property id = 'TransformCSS' >";    xml += "<string1>";    xml += "/*Supported by Firefox v3.5 or greater*/\n";    xml += "-moz-transform:";    xml += MatrixXML;		xml += "\n";		xml += "-moz-transform-origin:";		xml += TransformOriginXML;    xml += "\n\n";    xml += "/*Supported by Safari v3.1 or greater and by Chrome v9.0 or greater*/\n";    xml += "-webkit-transform:";    xml += MatrixXML;    xml += "\n";		xml += "-webkit-transform-origin:";		xml += TransformOriginXML;		xml += "\n\n";    xml += "/*Supported by Opera v10.5 or greater*/\n";    xml += "-o-transform: ";    xml += MatrixXML;    xml += "\n";		xml += "-o-transform-origin:";		xml += TransformOriginXML;		xml += "\n\n";		xml += "/* IE v10+ */\n";		xml += "-ms-transform:";    xml += MatrixXML;		xml += "\n";		xml += "-ms-transform-origin:";		xml += TransformOriginXML;    xml += "\n\n";						xml += "transform:";    xml += MatrixXML;		xml += "\n";		xml += "transform-origin:";		xml += TransformOriginXML;    xml += "\n\n";    xml += "progid:DXImageTransform.Microsoft.Matrix(";    xml += "M11 = ";    xml += Math.round(tMatrix[0] * 100)/100;    xml += ",M21 = ";    xml += Math.round(tMatrix[1] * 100)/100;    xml += ",M12 = ";    xml += Math.round(tMatrix[3] * 100)/100;    xml += ",M22 = ";    xml += Math.round(tMatrix[4] * 100)/100;		xml += ", SizingMethod = 'auto expand'";    xml += ");"			    xml += "</string1>";    xml += "</property>";  }  return xml;}//--------------------------------------------------------------------// FUNCTION://   __setMicrosoftGlowProperty//// DESCRIPTION://   This function extracts the glow property from the FW glow object and maps it to the IE glow filter property//// ARGUMENTS://   EffectsList - The list of FW effects object//// RETURNS://   XML specifying the mapping//--------------------------------------------------------------------function __setMicrosoftGlowProperty(EffectsList, Type, currentSelection){		var i = 0;	var flag = 0;	var PropertyTag = "";	var PropertyTagCSS = "";	var BoxShadowxml = "";	var BoxShadowCSSxml = "";	var FirefoxBoxShadow = "";	var WebkitBoxShadow = "";	var wwwSpec = "";	var MicrosoftDropShadow = "";	var xml = "";	PropertyTag = "<property id = 'MicrosoftGlow' >";	PropertyTagCSS = "<property id = 'MicrosoftGlowCSS' >";  var globalOpacity = currentSelection.opacity/100;	for(var i = 0; i < EffectsList.effects.length; i++)	{	  if(EffectsList.effects[i].EffectMoaID.match('{8eeadf50-9efe-11da-a7460800200c9a66}') && EffectsList.effects[i].EffectIsVisible)	  {         var splitOuterGlowObject = 0;         if(typeof(EffectsList.effects[i].outerGlow) != 'undefined')         {          splitOuterGlowObject = EffectsList.effects[i].outerGlow.split("&");          if(splitOuterGlowObject[0] != "1")          {            splitOuterGlowObject = 0;          }         }	          if(splitOuterGlowObject)        {           if(flag)            {              BoxShadowCSSxml += " ,";	            MicrosoftDropShadow += " progid:DXImageTransform.Microsoft.Glow("            }            else if(flag == 0)            {              if(Type == 'box-shadow:')              {	              wwwSpec += "box-shadow:";		              }              else              {	              wwwSpec += "text-shadow:";              }		            MicrosoftDropShadow += "filter:progid:DXImageTransform.Microsoft.Glow(";                            FirefoxBoxShadow += "-moz-";              FirefoxBoxShadow += wwwSpec;              WebkitBoxShadow += "-webkit-";              WebkitBoxShadow += wwwSpec;              BoxShadowxml += PropertyTag;              BoxShadowxml += "<string>";              flag = 1;            }                            var GlowParameters = splitOuterGlowObject[3].split(":");            var GlowOpacity = GlowParameters[0];            var GlowSpread = GlowParameters[1];            var GlowSize = GlowParameters[2];            var GlowRange = GlowParameters[5];            var GlowColors = splitOuterGlowObject[5].split(";");            var RedColor = GlowColors[1];            var GreenColor = GlowColors[2];            var BlueColor = GlowColors[3];            var MicrosoftGlow = "";              MicrosoftGlow += "Color = ";            MicrosoftGlow += "#";            MicrosoftGlow += parseFloat(Math.round((GlowOpacity/100) * 255)).toString(16);            if(RedColor < 16)              MicrosoftGlow += "0";                          MicrosoftGlow += parseFloat(RedColor).toString(16);            if(GreenColor < 16)              MicrosoftGlow += "0";                          MicrosoftGlow += parseFloat(GreenColor).toString(16);                if(BlueColor < 16)                  MicrosoftGlow += "0";            MicrosoftGlow += parseFloat(Math.round(BlueColor)).toString(16);            MicrosoftGlow += " ,";            MicrosoftGlow += "Strength = ";            MicrosoftGlow += Math.round(GlowSize);            MicrosoftGlow += ")";            MicrosoftDropShadow += MicrosoftGlow;            BoxShadowCSSxml += __ParsePhotoshopLiveEffectsGlowParse(splitOuterGlowObject, currentSelection);          }	  }		if((EffectsList.effects[i].EffectMoaID.match('{7fe61102-6ce2-11d1-8c76000502701850}') && EffectsList.effects[i].BevelType == 4)  && EffectsList.effects[i].EffectIsVisible)		{			 if(flag)			  {				  BoxShadowCSSxml += " ,";					MicrosoftDropShadow += " progid:DXImageTransform.Microsoft.Glow("			  }			  else if(flag == 0)			  {				  if(Type == 'box-shadow:')				  {					  wwwSpec += "box-shadow:";										  }				  else				  {					  wwwSpec += "text-shadow:";				  }										MicrosoftDropShadow += "filter:progid:DXImageTransform.Microsoft.Glow(";				  				  FirefoxBoxShadow += "-moz-";				  FirefoxBoxShadow += wwwSpec;								  WebkitBoxShadow += "-webkit-";				  WebkitBoxShadow += wwwSpec;				  BoxShadowxml += PropertyTag;				  BoxShadowxml += "<string>";				  flag = 1;		    }     		  var GlowWidth = 0;		      if(Type == "box-shadow:")				     GlowWidth = EffectsList.effects[i].GlowWidth;			    MicrosoftDropShadow += "Color = ";			    MicrosoftDropShadow += "#";			    if(EffectsList.effects[i].BevelContrast)				    MicrosoftDropShadow += Math.round(parseInt(EffectsList.effects[i].BevelContrast/100 * 255 * globalOpacity)).toString(16);                MicrosoftDropShadow += EffectsList.effects[i].OuterBevelColor.substr(1,6);          MicrosoftDropShadow += " ,";          MicrosoftDropShadow += "Strength = ";          MicrosoftDropShadow += (EffectsList.effects[i].MaskSoftness + EffectsList.effects[i].GlowWidth);          MicrosoftDropShadow += ")";			    BoxShadowCSSxml += __GetBoxShadowXML(EffectsList, 0, 0, i, GlowWidth, EffectsList.effects[i].MaskSoftness, EffectsList.effects[i].OuterBevelColor, EffectsList.effects[i].BevelContrast, currentSelection);		}	}  	for(var i = EffectsList.effects.length - 1; i >= 0 && Type == "box-shadow"; i--)	{  	  if(EffectsList.effects[i].EffectMoaID.match('{8eeadf50-9efe-11da-a7460800200c9a66}') && EffectsList.effects[i].EffectIsVisible)  	  {       var splitinnerGlowObject = EffectsList.effects[i].innerGlow.split("&");        if(splitinnerGlowObject[0] == "1")        {  			  if(flag)			  {				  BoxShadowCSSxml += " ,inset ";			  }			  else if(flag == 0)			  {				  if(Type == 'box-shadow:')				  {					  wwwSpec += "box-shadow:inset ";										  }									  				  FirefoxBoxShadow += "-moz-";				  FirefoxBoxShadow += wwwSpec;								  WebkitBoxShadow += "-webkit-";				  WebkitBoxShadow += wwwSpec;				  BoxShadowxml += PropertyTag;				  BoxShadowxml += "<string>";				  flag = 1;		    }          BoxShadowCSSxml += __ParsePhotoshopLiveEffectsGlowParse(splitinnerGlowObject, currentSelection);        }  	  }    if((EffectsList.effects[i].EffectMoaID.match('{2ba87123-8220-11d3-baad0000861f4d01}')) && EffectsList.effects[i].EffectIsVisible && Type == "box-shadow:")    {			 if(flag)			  {				  BoxShadowCSSxml += " ,inset ";			  }			  else if(flag == 0)			  {				  if(Type == 'box-shadow:')				  {					  wwwSpec += "box-shadow:inset ";										  }									  				  FirefoxBoxShadow += "-moz-";				  FirefoxBoxShadow += wwwSpec;								  WebkitBoxShadow += "-webkit-";				  WebkitBoxShadow += wwwSpec;				  BoxShadowxml += PropertyTag;				  BoxShadowxml += "<string>";				  flag = 1;		    }			  BoxShadowCSSxml += __GetBoxShadowXML(EffectsList, 0, 0, i, GlowWidth, EffectsList.effects[i].MaskSoftness, EffectsList.effects[i].OuterBevelColor, EffectsList.effects[i].BevelContrast, currentSelection);    }   } 	if(flag)	{    if(wwwSpec.match("inset"))      BoxShadowxml += "inset ";		BoxShadowxml += BoxShadowCSSxml;		BoxShadowxml += "</string>";		BoxShadowxml += "</property>";		BoxShadowCSSxml += ";";		    if(MicrosoftDropShadow.match("progid"))      MicrosoftDropShadow += ";";		wwwSpec += BoxShadowCSSxml;		FirefoxBoxShadow += BoxShadowCSSxml;		WebkitBoxShadow += BoxShadowCSSxml;    var MozillaComment = "/* Firefox v3.5+ */\n";    var WebkitComment = "/* Safari v3.0+ and by Chrome v0.2+ */\n";    var NormalComment = "/* Firefox v4.0+ , Safari v5.1+ , Chrome v10.0+, IE v10+ and by Opera v10.5+ */\n";    if(Type == 'box-shadow:')		  xml += BoxShadowxml +PropertyTagCSS + "<string1>" + MozillaComment + FirefoxBoxShadow + "\n" + WebkitComment + WebkitBoxShadow + "\n" + NormalComment + wwwSpec + "\n\n" + MicrosoftDropShadow + "</string1>" + "</property>";		else		  xml += BoxShadowxml +PropertyTagCSS + "<string1>" + NormalComment + wwwSpec + "\n\n" + MicrosoftDropShadow + "</string1>" + "</property>";		return (xml);	}	else		return "";} //--------------------------------------------------------------------// FUNCTION://   __getMicrosoftGlowPropertyAtIndex//// DESCRIPTION://   This function extracts the glow property from the FW glow object present at index i//// ARGUMENTS://   EffectsList - The list of FW effects object//// RETURNS://   XML specifying the mapping//--------------------------------------------------------------------function __getMicrosoftGlowPropertyAtIndex(EffectsList, i){      var MicrosoftGlow = "";      MicrosoftGlow += "progid:DXImageTransform.Microsoft.Glow(";  			MicrosoftGlow += "Color = ";			MicrosoftGlow += "#";			if(EffectsList.effects[i].OuterBevelColor.substr(7,2))				MicrosoftGlow += EffectsList.effects[i].OuterBevelColor.substr(7,2);			else      	MicrosoftGlow += "ff";      MicrosoftGlow += EffectsList.effects[i].OuterBevelColor.substr(1,6);      MicrosoftGlow += " ,";      MicrosoftGlow += "Strength = ";      MicrosoftGlow += (EffectsList.effects[i].MaskSoftness + EffectsList.effects[i].GlowWidth);      MicrosoftGlow += ")";      return MicrosoftGlow;}//--------------------------------------------------------------------// FUNCTION://   __ExtractOpacity//// DESCRIPTION://   extract opacity property//// ARGUMENTS://   element - The selected object reference//// RETURNS://   <type and description>//--------------------------------------------------------------------function __ExtractOpacity(element){  var ReturnOpacityXML = "";	if(element.opacity != 100)	{		ReturnOpacityXML += "<property id = 'Opacity' >";								//extract the opacity		ReturnOpacityXML += "<string>";		ReturnOpacityXML += Math.round(element.opacity)/100;		ReturnOpacityXML += "</string>";		ReturnOpacityXML += "</property>";			ReturnOpacityXML += "<property id = 'OpacityCSS' >";		ReturnOpacityXML += "<string1>";		ReturnOpacityXML += "opacity:";		ReturnOpacityXML += Math.round(element.opacity)/100;		ReturnOpacityXML += ";";				ReturnOpacityXML += __GetMicrosoftAlphaFilterXML(element, null, 1, true);						ReturnOpacityXML += "</string1>";		ReturnOpacityXML += "</property>";	}  return ReturnOpacityXML;} //--------------------------------------------------------------------// FUNCTION://  __setBoxShadowProperty//// DESCRIPTION://   Extracts the box shadow property//// ARGUMENTS://   EffectsList - The list of filter properties applied to the current selection//   ObjectType - Type of object present can be either text or artwork//   KnockOutCaseForShadows - Is the knockout shadow checkbox on?//// RETURNS://   <type and description>//--------------------------------------------------------------------function __setBoxShadowProperty(EffectsList, ObjectType, KnockOutCaseForShadows, currentSelection){	var i = 0;	var flag = 0;	var PropertyTag = "";	var PropertyTagCSS = "";	var BoxShadowxml = "";	var BoxShadowCSSxml = "";	var FirefoxBoxShadow = "";	var WebkitBoxShadow = "";	var wwwSpec = "";	var MicrosoftDropShadow = "";	var MicrosoftHasOnlyOneDropShadow = 0;	var MergedCodeXML = "";	var MozillaMergedCodeXML = "";	var WebkitMergedCodeXML = "";	var wwwSpecMergedCodeXML = "";	var PropertyTagMergedCode = "";	var xml = "";	var MicrosoftMergedDropShadow = "";	var OnlyGlowPresent = false;	if(ObjectType == 'Artwork')	{		PropertyTag = "<property id = 'BoxShadow' >";		PropertyTagCSS = "<property id = 'BoxShadowCSS' >";		PropertyTagMergedCode = "<property id = 'BoxShadowCSSMerged' >";	}	else	{		PropertyTag = "<property id = 'TextShadow' >";		PropertyTagCSS = "<property id = 'TextShadowCSS' >";		PropertyTagMergedCode = "<property id = 'TextShadowCSSMerged' >";	}	for(var i = 0; i < EffectsList.effects.length; i++)	{	  if(EffectsList.effects[i].EffectMoaID.match('{8eeadf50-9efe-11da-a7460800200c9a66}') && EffectsList.effects[i].EffectIsVisible)	  {          var splitouterGlowObject = 0;          var splitouterShadowObject = 0;                              if(typeof(EffectsList.effects[i].outerGlow) != 'undefined')          {            splitouterGlowObject = EffectsList.effects[i].outerGlow.split("&");            if(splitouterGlowObject[0] != "1")              splitouterGlowObject = 0;          }                      if(typeof(EffectsList.effects[i].dropShadow) != 'undefined')          {            splitouterShadowObject = EffectsList.effects[i].dropShadow.split("&");            if(splitouterShadowObject[0] != "1")              splitouterShadowObject = 0;          }          if(splitouterGlowObject)          {			       if(OnlyGlowPresent == false)			        OnlyGlowPresent = true;		        else			       	MergedCodeXML += " ,";              MergedCodeXML += __ParsePhotoshopLiveEffectsGlowParse(splitouterGlowObject, currentSelection);              MicrosoftMergedDropShadow += __ParsePhotoshopLiveEffectsMSGlow(splitouterGlowObject, currentSelection);              MicrosoftHasOnlyOneDropShadow = 1;		       	                      }          if(splitouterShadowObject)          {			      if(flag)			      {				      				      BoxShadowCSSxml += " ,";					    //MergedCodeXML += " ,";					    if(MicrosoftDropShadow.match('filter'))					    {					      MicrosoftDropShadow += "\nprogid:DXImageTransform.Microsoft.dropshadow(";					    }					    else					    {					      MicrosoftDropShadow += "filter:progid:DXImageTransform.Microsoft.dropshadow(";					    }					    MicrosoftMergedDropShadow += "\nprogid:DXImageTransform.Microsoft.dropshadow(";			      }			      else if(flag == 0)			      {				      if(ObjectType == 'Artwork')				      {					      wwwSpec += "box-shadow:";										      }				      else				      {					      wwwSpec += "text-shadow:";				      }										    MicrosoftDropShadow += "filter:progid:DXImageTransform.Microsoft.dropshadow(";				      MicrosoftMergedDropShadow += "\nprogid:DXImageTransform.Microsoft.dropshadow(";				      FirefoxBoxShadow += "-moz-";				      FirefoxBoxShadow += wwwSpec;								      WebkitBoxShadow += "-webkit-";				      WebkitBoxShadow += wwwSpec;				      BoxShadowxml += PropertyTag;				      BoxShadowxml += "<string>";				      flag = 1;		        }                          BoxShadowCSSxml += __ParsePhotoshopLiveEffectsShadowParse(splitouterShadowObject, currentSelection);		       if(OnlyGlowPresent == false)			        OnlyGlowPresent = true;		        else			       	MergedCodeXML += " ,";              MergedCodeXML += __ParsePhotoshopLiveEffectsShadowParse(splitouterShadowObject, currentSelection);              MicrosoftDropShadow += __ParsePhotoshopLiveEffectsMSShadow(splitouterShadowObject, KnockOutCaseForShadows, currentSelection);              MicrosoftMergedDropShadow += __ParsePhotoshopLiveEffectsMSShadow(splitouterShadowObject, KnockOutCaseForShadows, currentSelection);              MicrosoftHasOnlyOneDropShadow = 1;          }          	  }		if(EffectsList.effects[i].EffectMoaID.match('{a7944db8-6ce2-11d1-8c76000502701850}'))		{//alert(EffectsList.effects[i].ShadowAngle);	  	var ShadowAngle = (EffectsList.effects[i].ShadowAngle * Math.PI) / 180 + ( Math.PI)/2;	    var XDistance = Math.round(EffectsList.effects[i].ShadowDistance * Math.sin(ShadowAngle));	    var YDistance = Math.round(EffectsList.effects[i].ShadowDistance * Math.cos(ShadowAngle));	    var ShadowBlur = EffectsList.effects[i].ShadowBlur;		  if(EffectsList.effects[i].EffectIsVisible)		  {			  			  if(flag)			  {				  				  BoxShadowCSSxml += " ,";					//MergedCodeXML += " ,";					if(MicrosoftDropShadow.match('filter'))					{					  MicrosoftDropShadow += "\nprogid:DXImageTransform.Microsoft.dropshadow(";					}					else					{					  MicrosoftDropShadow += "filter:progid:DXImageTransform.Microsoft.dropshadow(";					}					MicrosoftMergedDropShadow += "\nprogid:DXImageTransform.Microsoft.dropshadow(";			  }			  else if(flag == 0)			  {				  if(ObjectType == 'Artwork')				  {					  wwwSpec += "box-shadow:";										  }				  else				  {					  wwwSpec += "text-shadow:";				  }										MicrosoftDropShadow += "filter:progid:DXImageTransform.Microsoft.dropshadow(";				  MicrosoftMergedDropShadow += "\nprogid:DXImageTransform.Microsoft.dropshadow(";				  FirefoxBoxShadow += "-moz-";				  FirefoxBoxShadow += wwwSpec;								  WebkitBoxShadow += "-webkit-";				  WebkitBoxShadow += wwwSpec;				  BoxShadowxml += PropertyTag;				  BoxShadowxml += "<string>";				  flag = 1;		    }			  			 			 BoxShadowCSSxml += __GetBoxShadowXML(EffectsList, XDistance, YDistance, i, 0, EffectsList.effects[i].ShadowBlur, EffectsList.effects[i].ShadowColor, -1, currentSelection);			 if(OnlyGlowPresent == false)			  OnlyGlowPresent = true;		  else			 	MergedCodeXML += " ,";			 MergedCodeXML += __GetBoxShadowXML(EffectsList, XDistance, YDistance, i, 0, EffectsList.effects[i].ShadowBlur, EffectsList.effects[i].ShadowColor, -1, currentSelection);			 MicrosoftDropShadow += __GetMicrosoftBoxShadowXML(EffectsList, XDistance, YDistance, i, KnockOutCaseForShadows, currentSelection);			 MicrosoftMergedDropShadow += __GetMicrosoftBoxShadowXML(EffectsList, XDistance, YDistance, i, KnockOutCaseForShadows, currentSelection);			 MicrosoftHasOnlyOneDropShadow = 1;		  }	  }		if(EffectsList.effects[i].EffectMoaID.match('{7fe61102-6ce2-11d1-8c76000502701850}') && EffectsList.effects[i].BevelType == 4 && EffectsList.effects[i].EffectIsVisible)		{			 var GlowWidth = 0;			 if(ObjectType == 'Artwork')			 	GlowWidth = EffectsList.effects[i].GlowWidth;						 if(OnlyGlowPresent == false)			  OnlyGlowPresent = true;		  else			 	MergedCodeXML += " ,";			 MergedCodeXML += __GetBoxShadowXML(EffectsList, 0, 0, i, GlowWidth, EffectsList.effects[i].MaskSoftness, EffectsList.effects[i].OuterBevelColor, EffectsList.effects[i].BevelContrast, currentSelection);			 MicrosoftMergedDropShadow += "\n" + __getMicrosoftGlowPropertyAtIndex(EffectsList, i);			 MicrosoftHasOnlyOneDropShadow = 1;		}	}  	for(var i = EffectsList.effects.length - 1; i >= 0; i--)	{    if(EffectsList.effects[i].EffectMoaID.match('{8eeadf50-9efe-11da-a7460800200c9a66}') && EffectsList.effects[i].EffectIsVisible && ObjectType == 'Artwork')    {          var splitinnerGlowObject = 0;          var splitInnerShadowObject = 0;          if(typeof(EffectsList.effects[i].innerGlow) != 'undefined')          {            splitinnerGlowObject = EffectsList.effects[i].innerGlow.split("&");            if(splitinnerGlowObject[0] != "1")              splitinnerGlowObject = 0;          }                      if(typeof(EffectsList.effects[i].innerShadow) != 'undefined')          {            splitInnerShadowObject = EffectsList.effects[i].innerShadow.split("&");            if(splitInnerShadowObject[0] != "1")              splitInnerShadowObject = 0;          }                    if(splitinnerGlowObject)          {            if(flag)            {	            	            BoxShadowCSSxml += " ,inset ";				      //MergedCodeXML += " ,inset ";            }		        else if(flag == 0)		        {			        wwwSpec += "box-shadow:inset ";						        FirefoxBoxShadow += "-moz-";			        FirefoxBoxShadow += wwwSpec;						        WebkitBoxShadow += "-webkit-";			        WebkitBoxShadow += wwwSpec;						        BoxShadowxml += "<property id = 'BoxShadow' >";			        BoxShadowxml += "<string>";			        flag = 1;		        }              BoxShadowCSSxml += __ParsePhotoshopLiveEffectsGlowParse(splitinnerGlowObject, currentSelection);			       if(OnlyGlowPresent == false)			       {   			        OnlyGlowPresent = true;                MergedCodeXML += "inset ";			       }		        else			       	MergedCodeXML += " ,inset ";              MergedCodeXML += __ParsePhotoshopLiveEffectsGlowParse(splitinnerGlowObject, currentSelection);          }          if(splitInnerShadowObject)          {            if(flag)            {	            	            BoxShadowCSSxml += " ,inset ";				      //MergedCodeXML += " ,inset ";            }		        else if(flag == 0)		        {			        wwwSpec += "box-shadow:inset ";						        FirefoxBoxShadow += "-moz-";			        FirefoxBoxShadow += wwwSpec;						        WebkitBoxShadow += "-webkit-";			        WebkitBoxShadow += wwwSpec;						        BoxShadowxml += "<property id = 'BoxShadow' >";			        BoxShadowxml += "<string>";			        flag = 1;		        }            BoxShadowCSSxml += __ParsePhotoshopLiveEffectsShadowParse(splitInnerShadowObject, currentSelection);                  		  if(OnlyGlowPresent == false)            {			        OnlyGlowPresent = true;              MergedCodeXML += "inset ";            }	         else			       	MergedCodeXML += " ,inset ";            MergedCodeXML += __ParsePhotoshopLiveEffectsShadowParse(splitInnerShadowObject, currentSelection);                    }    }    if(EffectsList.effects[i].EffectMoaID.match('{2ba87123-8220-11d3-baad0000861f4d01}') && EffectsList.effects[i].EffectIsVisible && ObjectType == 'Artwork')    {      if(flag)      {                BoxShadowCSSxml += " ,inset ";	      //MergedCodeXML += " ,inset ";      }      else if(flag == 0)      {        wwwSpec += "box-shadow:inset ";        FirefoxBoxShadow += "-moz-";        FirefoxBoxShadow += wwwSpec;        WebkitBoxShadow += "-webkit-";        WebkitBoxShadow += wwwSpec;        BoxShadowxml += "<property id = 'BoxShadow' >";        BoxShadowxml += "<string>";        flag = 1;      }      BoxShadowCSSxml += __GetBoxShadowXML(EffectsList, 0, 0, i, GlowWidth, EffectsList.effects[i].MaskSoftness, EffectsList.effects[i].OuterBevelColor, EffectsList.effects[i].BevelContrast, currentSelection);		 if(OnlyGlowPresent == false)      {			  OnlyGlowPresent = true;        MergedCodeXML += "inset ";      }	   else			 	MergedCodeXML += " ,inset "; 		  MergedCodeXML += __GetBoxShadowXML(EffectsList, 0, 0, i, GlowWidth, EffectsList.effects[i].MaskSoftness, EffectsList.effects[i].OuterBevelColor, EffectsList.effects[i].BevelContrast, currentSelection);    }	  if(EffectsList.effects[i].EffectMoaID.match('{5600f702-774c-11d3-baad0000861f4d01}') && ObjectType == 'Artwork' && EffectsList.effects[i].EffectIsVisible)	  {	       	var ShadowAngle = (EffectsList.effects[i].ShadowAngle * Math.PI) / 180 + ( Math.PI)/2;	    var XDistance = Math.round(EffectsList.effects[i].ShadowDistance * Math.sin(ShadowAngle));	    var YDistance = Math.round(EffectsList.effects[i].ShadowDistance * Math.cos(ShadowAngle));	          var ShadowBlur = EffectsList.effects[i].ShadowBlur;            if(flag)      {	      	      BoxShadowCSSxml += " ,inset ";				//MergedCodeXML += " ,inset ";      }		  else if(flag == 0)		  {			  wwwSpec += "box-shadow:inset ";						  FirefoxBoxShadow += "-moz-";			  FirefoxBoxShadow += wwwSpec;						  WebkitBoxShadow += "-webkit-";			  WebkitBoxShadow += wwwSpec;						  BoxShadowxml += "<property id = 'BoxShadow' >";			  BoxShadowxml += "<string>";			  flag = 1;		  }				  		  BoxShadowCSSxml += __GetBoxShadowXML(EffectsList, XDistance, YDistance, i, 0, EffectsList.effects[i].ShadowBlur, EffectsList.effects[i].ShadowColor, -1, currentSelection);		 if(OnlyGlowPresent == false)      {			  OnlyGlowPresent = true;        MergedCodeXML += "inset ";      }	   else			 	MergedCodeXML += " ,inset "; 		  MergedCodeXML += __GetBoxShadowXML(EffectsList, XDistance, YDistance, i, 0, EffectsList.effects[i].ShadowBlur, EffectsList.effects[i].ShadowColor, -1, currentSelection);	  }  }	if(flag || OnlyGlowPresent)	{	  if(flag)	  {      if(wwwSpec.match("inset"))        BoxShadowxml += "inset ";	    BoxShadowxml += BoxShadowCSSxml;	    BoxShadowxml += "</string>";	    BoxShadowxml += "</property>";		  BoxShadowCSSxml += ";";		}		MergedCodeXML += ";";		if(MicrosoftHasOnlyOneDropShadow)		{		  if(flag && OnlyGlowPresent == false)			  MicrosoftDropShadow += ";";			  			MicrosoftMergedDropShadow += ";";    }    if(ObjectType == 'Artwork')		  wwwSpecMergedCodeXML = "box-shadow:";		else		  wwwSpecMergedCodeXML = "text-shadow:";		wwwSpecMergedCodeXML += MergedCodeXML;		if(ObjectType == 'Artwork')		  MozillaMergedCodeXML = "-moz-box-shadow:";		else		  MozillaMergedCodeXML = "-moz-text-shadow:";		MozillaMergedCodeXML += MergedCodeXML;		if(ObjectType == 'Artwork')		  WebkitMergedCodeXML = "-webkit-box-shadow:";		else		  WebkitMergedCodeXML = "-webkit-text-shadow:";		WebkitMergedCodeXML += MergedCodeXML;		wwwSpec += BoxShadowCSSxml;		FirefoxBoxShadow += BoxShadowCSSxml;		WebkitBoxShadow += BoxShadowCSSxml;    var MozillaComment = "/* Firefox v3.5+ */\n";    var WebkitComment = "/* Safari v3.0+ and by Chrome v0.2+ */\n";    var NormalComment = "/* Firefox v4.0+ , Safari v5.1+ , Chrome v10.0+  and by Opera v10.5+ */\n";		  		if(ObjectType == 'Artwork')		{		  xml += PropertyTagMergedCode + "<string1>" + MozillaComment + MozillaMergedCodeXML + "\n" + WebkitComment + WebkitMergedCodeXML +"\n"+ NormalComment + wwwSpecMergedCodeXML+ "\n\n" + MicrosoftMergedDropShadow + "</string1>" + "</property>";				}		else		{		  xml += PropertyTagMergedCode + "<string1>" + NormalComment + wwwSpecMergedCodeXML+ "\n\n" + MicrosoftMergedDropShadow + "</string1>" + "</property>";			}  		return (xml);	}	else		return null;}//--------------------------------------------------------------------// FUNCTION://  __GetCornerRadius//// DESCRIPTION://   returns the corner radius of the autoshape//// ARGUMENTS://   pt1 - //   PT2 - // RETURNS://   <type and description>//--------------------------------------------------------------------function __GetCornerRadius(pt1, pt2){  return Math.round(pt1.x - pt2.x);}//--------------------------------------------------------------------// FUNCTION://  __CheckForKnockOutShadow//// DESCRIPTION://   Checks if the Knockout check box is present//// ARGUMENTS://   pt1 - //   PT2 - // RETURNS://   <type and description>//--------------------------------------------------------------------function __CheckForKnockOutShadow(EffectsList){  for(var i = 0; i < EffectsList.effects.length; i++)	{	  if(EffectsList.effects[i].EffectMoaID.match('{a7944db8-6ce2-11d1-8c76000502701850}') || EffectsList.effects[i].EffectMoaID.match('{5600f702-774c-11d3-baad0000861f4d01}'))	  {	    	    if(EffectsList.effects[i].ShadowType)	      return true;	  }  }    return false;}//--------------------------------------------------------------------// FUNCTION://  __GetColorStops//// DESCRIPTION://   Gets the mozilla style color stops//// ARGUMENTS://   pt1 - //   PT2 - // RETURNS://   <type and description>//--------------------------------------------------------------------function __GetColorStops(GradNodes, OpacityNodes, currentSelection, whichBrowser){  var ReturnXML = "", FirstOpacityStopNotToBeIgnored = 0, globalOpacity = Math.round(currentSelection.opacity)/100;  var AlphaValue = 1;  var cnt_i = 0, cnt_j = 0;	for(cnt_i = 0, cnt_j = 0; cnt_i < GradNodes.length && cnt_j < OpacityNodes.length; )	{	    var GradNodePosition = Math.round(GradNodes[cnt_i].position*100);      var OpacityNodePosition = Math.round(OpacityNodes[cnt_j].position*100);      if(GradNodePosition < OpacityNodePosition)      {        ReturnXML += __GetGradColor(GradNodes, OpacityNodes, globalOpacity, cnt_i, whichBrowser);	      cnt_i++;	    }	    else	    {        ReturnXML += __GetOpacity(GradNodes, OpacityNodes, globalOpacity,cnt_j, whichBrowser);				if(OpacityNodePosition == GradNodePosition)				{				  cnt_i++;				}        cnt_j++;			 	    } 	}  for(; cnt_i < GradNodes.length; cnt_i++)  {    ReturnXML += __GetGradColor(GradNodes, OpacityNodes, globalOpacity, cnt_i, whichBrowser);  }  for(; cnt_j < OpacityNodes.length; cnt_j++)  {    ReturnXML += __GetOpacity(GradNodes, OpacityNodes, globalOpacity, cnt_j, whichBrowser);  }  return ReturnXML;}//--------------------------------------------------------------------// FUNCTION://  __GetGradColor//// DESCRIPTION://   Gets the mozilla style color stops//// ARGUMENTS://   pt1 - //   PT2 - // RETURNS://   <type and description>//--------------------------------------------------------------------function __GetGradColor(GradNodes, OpacityNodes, globalOpacity, cnt_i, whichBrowser){  var AlphaValue = 1;  var ReturnXML = "";  AlphaValue = __getGradientValue(OpacityNodes,GradNodes[cnt_i].position,"Alpha");  AlphaValue = AlphaValue * globalOpacity;  AlphaValue = Math.round(AlphaValue * 100)/100;  if(whichBrowser == 2)  {  			ReturnXML += "color-stop(";			ReturnXML += Math.round(GradNodes[cnt_i].position * 100)/100;			ReturnXML+=", ";  }  if(AlphaValue == 1)  {    ReturnXML += "rgb(";  }  else    ReturnXML += "rgba(";  ReturnXML += parseInt((GradNodes[cnt_i].color.substr(1,2)),16);  ReturnXML += ",";  ReturnXML += parseInt((GradNodes[cnt_i].color.substr(3,2)),16);  ReturnXML += ",";  ReturnXML += parseInt((GradNodes[cnt_i].color.substr(5,2)),16);  if(AlphaValue != 1)  {    ReturnXML += ",";    ReturnXML += AlphaValue;  }  if(whichBrowser == 2)  {  			ReturnXML += ")";			ReturnXML += ")";		  }  else  {    ReturnXML += ")";    ReturnXML += " ";    ReturnXML += Math.round(GradNodes[cnt_i].position*100);    ReturnXML += "%";								  }  if(cnt_i + 1 < GradNodes.length || GradNodes[GradNodes.length - 1].position < OpacityNodes[OpacityNodes.length - 1].position)    ReturnXML += ",";  return ReturnXML;}//--------------------------------------------------------------------// FUNCTION://  __GetOpacity//// DESCRIPTION://   Gets the mozilla style color stops//// ARGUMENTS://   pt1 - //   PT2 - // RETURNS://   <type and description>//--------------------------------------------------------------------function __GetOpacity(GradNodes, OpacityNodes, globalOpacity, cnt_j, whichBrowser){  var AlphaValue = 1;  var ReturnXML = "";  if(OpacityNodes[cnt_j].color.length > 7)    AlphaValue = Math.round((parseInt((OpacityNodes[cnt_j].color.substr(7,2)),16)/255)* 100)/100;  else    AlphaValue = 1;  AlphaValue = AlphaValue * globalOpacity;  AlphaValue = Math.round(AlphaValue * 100)/100;    if(whichBrowser == 2)  {  			ReturnXML += "color-stop(";			ReturnXML += Math.round(OpacityNodes[cnt_j].position * 100)/100;			ReturnXML+=", ";  }  if(AlphaValue == 1)    ReturnXML += "rgb(";  else    ReturnXML += "rgba(";  ReturnXML += __getGradientValue(GradNodes,OpacityNodes[cnt_j].position,"Color");  if(AlphaValue != 1)  {    ReturnXML += ",";    ReturnXML += AlphaValue;    }  if(whichBrowser == 2)  {  			ReturnXML += ")";			ReturnXML += ")";		  }  else  {    ReturnXML += ")";    ReturnXML += " ";    ReturnXML += Math.round(OpacityNodes[cnt_j].position*100);    ReturnXML += "%";    }    if(cnt_j + 1 < OpacityNodes.length || OpacityNodes[OpacityNodes.length - 1].position < GradNodes[GradNodes.length - 1].position)    ReturnXML += ",";  return ReturnXML;}//--------------------------------------------------------------------// FUNCTION://  __GetRadialSizeConstant//// DESCRIPTION://   Gets the radial size constant for mozilla radial gradient. See the mozilla css reference for the property description  //// ARGUMENTS://   pt1 - //   PT2 - // RETURNS://   <type and description>//--------------------------------------------------------------------function __GetRadialSizeConstant(Pt1, Pt2, SelectedRectLeft, SelectedRectTop, SelectedRectRight, SelectedRectBottom, radius){   var ClosestSide, FarthestSide, ClosestCorner, FarthestCorner, RadialSizeConstant = "";   var d1,d2,d3,d4;   d1 = Math.abs(Pt1.x - SelectedRectRight);   d2 = Math.abs(Pt1.y - SelectedRectBottom);   d3 = Math.abs(Pt1.y - SelectedRectTop);   ClosestSide = Math.abs(Pt1.x - SelectedRectLeft);   ClosestSide = Math.min(ClosestSide, d1);   ClosestSide = Math.min(ClosestSide, d2);   ClosestSide = Math.min(ClosestSide, d3);   FarthestSide = Math.abs(Pt1.x - SelectedRectLeft);   FarthestSide = Math.max(FarthestSide, d1);   FarthestSide = Math.max(FarthestSide, d2);   FarthestSide = Math.max(FarthestSide, d3);   d1 = Math.sqrt((Pt1.x - SelectedRectLeft) * (Pt1.x - SelectedRectLeft) + (Pt1.y - SelectedRectTop) * (Pt1.y - SelectedRectTop));   d2 = Math.sqrt((Pt1.x - SelectedRectRight) * (Pt1.x - SelectedRectRight) + (Pt1.y - SelectedRectTop) * (Pt1.y - SelectedRectTop));   d3 = Math.sqrt((Pt1.x - SelectedRectLeft) * (Pt1.x - SelectedRectLeft) + (Pt1.y - SelectedRectBottom) * (Pt1.y - SelectedRectBottom));   d4 = Math.sqrt((Pt1.x - SelectedRectRight) * (Pt1.x - SelectedRectRight) + (Pt1.y - SelectedRectBottom) * (Pt1.y - SelectedRectBottom));      ClosestCorner = d1;   ClosestCorner = Math.min(ClosestCorner, d2);   ClosestCorner = Math.min(ClosestCorner, d3);   ClosestCorner = Math.min(ClosestCorner, d4);   FarthestCorner = d1;   FarthestCorner = Math.max(FarthestCorner, d2);   FarthestCorner = Math.max(FarthestCorner, d3);   FarthestCorner = Math.max(FarthestCorner, d4);      var temp = Math.abs(radius - ClosestSide);   RadialSizeConstant = "closest-side";      if(Math.min(temp, Math.abs(radius - FarthestSide)) != temp)   {	  temp = Math.abs(radius - FarthestSide);	  RadialSizeConstant = "farthest-side";   }      if(Math.min(temp, Math.abs(radius - ClosestCorner)) != temp)   {	  temp = Math.abs(radius - ClosestCorner);	  RadialSizeConstant = "closest-corner";   }      if(Math.min(temp, Math.abs(radius - FarthestCorner)) != temp)   {	  temp = Math.abs(radius - FarthestCorner);	  RadialSizeConstant = "farthest-corner";   }//   if(temp > 100)												//check if its not too far from the sides. If its too far, the discretization would look pretty much stupid//	  ProcessRadialGradient = false;	 return RadialSizeConstant;}//--------------------------------------------------------------------// FUNCTION://  __GetBoxShadowXML//// DESCRIPTION://   Get the box shadow stops//// ARGUMENTS://   pt1 - //   PT2 - // RETURNS://   <type and description>//--------------------------------------------------------------------function __GetBoxShadowXML(EffectsList, XDistance, YDistance, i, Expansion, ShadowBlur, ShadowColor, BevelContrast, currentSelection){  var ReturnXML = "";  var globalOpacity = 1;  if(typeof(currentSelection) != 'undefined' && typeof(currentSelection.opacity) != 'undefined')  globalOpacity = currentSelection.opacity/100;  ReturnXML += XDistance;//Math.round(__ComputeTransformPointX(pt, Matrix));  ReturnXML += "px ";  ReturnXML += YDistance;//Math.round(__ComputeTransformPointY(pt, Matrix));  ReturnXML += "px ";  ReturnXML += ShadowBlur;  ReturnXML += "px ";  if(BevelContrast >= 0)  {    BevelContrast = Math.round(BevelContrast * globalOpacity);  }	if(Expansion)	{		ReturnXML += Expansion;  	ReturnXML += "px ";	}	if(ShadowColor.length > 7 || (BevelContrast >= 0 && BevelContrast < 100))    ReturnXML += "rgba(";  else    ReturnXML += "rgb(";  ReturnXML += parseInt(ShadowColor.substr(1,2),16);  ReturnXML += ",";  ReturnXML += parseInt(ShadowColor.substr(3,2),16);  ReturnXML += ",";  ReturnXML += parseInt(ShadowColor.substr(5,2),16);  if(ShadowColor.length > 7)  {    ReturnXML += ",";    ReturnXML += Math.round(((parseInt((ShadowColor.substr(7,2)),16))/255) * 100 * globalOpacity)/100;  }	else if(BevelContrast >= 0 && BevelContrast < 100)	{		ReturnXML += ",";    ReturnXML += BevelContrast/100;	}//  else//  {//     ReturnXML += ",";//     ReturnXML += "1";//  }  ReturnXML += ")";  return ReturnXML;}//--------------------------------------------------------------------// FUNCTION://  __GetMicrosoftAlphaFilter//// DESCRIPTION://   Extract the microsoft alpha property//// ARGUMENTS://   pt1 - //   PT2 - // RETURNS://   returns the XML containing the IE Alpha filter property//--------------------------------------------------------------------function __GetMicrosoftAlphaFilterXML(element, OpacityNodes, Style, MimicOpacity){  var ReturnXML = "", StartOpacity = 100, FinishOpacity = 100, globalOpacity = Math.round(element.opacity)/100;	ReturnXML += "progid:DXImageTransform.Microsoft.Alpha(";	StartOpacity = Math.round(StartOpacity * globalOpacity);	FinishOpacity = Math.round(FinishOpacity * globalOpacity);	if(MimicOpacity)		StartOpacity = FinishOpacity = Math.round(element.opacity);	else	{		if(OpacityNodes[0].color.substr(7,2))			StartOpacity = (StartOpacity/100) * Math.round(((parseInt((OpacityNodes[0].color.substr(7,2)),16))/255) * 100);		if(OpacityNodes[OpacityNodes.length - 1].color.substr(7,2))			FinishOpacity = (FinishOpacity/100) * Math.round(((parseInt((OpacityNodes[OpacityNodes.length - 1].color.substr(7,2)),16))/255) * 100);					//FinishOpacity = Math.round(((parseInt((OpacityNodes[OpacityNodes.length - 1].color.substr(7,2)),16))/255) * 100);	}	StartOpacity = Math.round(StartOpacity);	FinishOpacity = Math.round(FinishOpacity);	if(StartOpacity != "100" || FinishOpacity != "100")	{		ReturnXML += "Opacity = ";		ReturnXML += StartOpacity;		if(MimicOpacity == false)			ReturnXML += ",";	}			if(StartOpacity != FinishOpacity)	{				ReturnXML += "FinishOpacity = ";		ReturnXML += FinishOpacity;		ReturnXML += ",";		}			if(MimicOpacity == false)	{				ReturnXML += "Style = ";		ReturnXML += Style;	}			ReturnXML += ");\n\n";  return ReturnXML;}//--------------------------------------------------------------------// FUNCTION://  __ComputeInverseByLUDecomposition//// DESCRIPTION://   Computes inverse of the transform matrix//// ARGUMENTS://   pt1 - //   PT2 - // RETURNS://   inverted matrix //--------------------------------------------------------------------function __ComputeInverseByLUDecomposition(TransformMatrix){	var i = 0, j = 0, k = 0, n = 0, nm1 = 0, x = 0;	var sum = 0, diag = 0;	var a = new Object();		n = 3;	for(i = 0; i < 9; i++)	{	  a[i] = TransformMatrix[i];	}/******LU Decomposition********/  for(k = 0; k < n - 1; k++)  {    for(x = k + 1; x < n; x++)    {            a[x + k * 3] = a[x + k * 3]/a[k + k * 3];    }    for(i = k + 1; i < n; i++)    {      for(j = k + 1; j < n; j++)      {        a[i + j * 3] = a[i + j * 3] - a[i + k * 3] * a[k + j * 3];      }    }  }  var y = new Object();  y = [1,0,0,0,1,0,0,0,1];  var inverseA = new Object();  inverseA = [1,0,0,0,1,0,0,0,1];    /*****Forward substitution A = LU, AX = LUX, LY = AX, UX = Y********/  y[1] = -1 * a[1];  y[2] = -1 * a[2] + a[5] * a[1];  y[5] = -1 * a[5];  /*****Backward Substitution******/    inverseA[8] = 1/a[8];  inverseA[5] = y[5]/a[8];  inverseA[2] = y[2]/a[8];  inverseA[7] = -1 * ((a[7] * inverseA[8])/a[4]);  inverseA[4] = (1 - a[7] * inverseA[5])/a[4];  inverseA[1] = (y[1] - a[7] * inverseA[2])/ a[4];  inverseA[6] = (-1 * (a[3] * inverseA[7] + a[6] * inverseA[8]) )/ a[0];  inverseA[3] = (-1 * (a[3] * inverseA[4] + a[6] * inverseA[5]) )/ a[0];  inverseA[0] = (1 - (a[3] * inverseA[1] + a[6] * inverseA[2]) )/ a[0];	return inverseA;}// FUNCTION://  __SolidBackgroundColor//// DESCRIPTION://   extracts background-color css property//// ARGUMENTS://   fillcolor//   // RETURNS://   XML string containing the background css property//--------------------------------------------------------------------function __SolidBackgroundColor(fillColor, ObjectReference){	var Returnxml = "";	var fillColorCSS = "";  Returnxml += "<property id = 'BGColor' >";  Returnxml += "<string>";  var ObjectOpacity = 100;  if(fillColor.substr(7,2))    ObjectOpacity = parseInt(fillColor.substr(7,2), 16)/255 * 100;    	var Opacity = 100;	if(typeof(ObjectReference) != 'undefined')		Opacity = Math.round(ObjectOpacity * (ObjectReference.opacity/100))/100;	if(fillColor.match("transparent") || Opacity == 0)	{	  	  fillColorCSS = "transparent";	}	else	{    fillColorCSS = "rgb(";    if(Opacity < 1)      fillColorCSS = "rgba(";      fillColorCSS += parseInt(fillColor.substr(1,2), 16);    fillColorCSS += ",";    fillColorCSS += parseInt(fillColor.substr(3,2), 16);    fillColorCSS += ",";    fillColorCSS += parseInt(fillColor.substr(5,2), 16);    if(Opacity < 1)    {      fillColorCSS += ",";      fillColorCSS += Opacity;    }    fillColorCSS += ")";	}	  Returnxml += fillColorCSS;	Returnxml	+= "</string>"	Returnxml += "</property>";	Returnxml += "<property id = 'BGColorCSS' >";	Returnxml += "<string1>";	Returnxml += "background-color:";	Returnxml += fillColorCSS;	Returnxml += ";\n\n";	Returnxml	+= "</string1>"	Returnxml += "</property>";	return Returnxml;}//--------------------------------------------------------------------// FUNCTION://   __CheckIfRectangleAutoShape//// DESCRIPTION://   Checks if the autoshape is an rectangle//// ARGUMENTS://   nodes - //// RETURNS://   1 if its proper rectangle with rounded corners, 2,3 if its chamfered //--------------------------------------------------------------------function __CheckIfRectangleAutoShape(nodes){	if(nodes.length == 8)	{		if(Math.abs(nodes[0].succX - nodes[0].x) <= 0.1 && nodes[0].succY <= nodes[0].y)			{			if(Math.abs(nodes[1].predY - nodes[1].y) <= 0.1 && nodes[1].predX <= nodes[1].x)				{ 					if(Math.abs(nodes[2].succY - nodes[2].y) <=0.1 && nodes[2].succX >= nodes[2].x)					{												if(Math.abs(nodes[3].predX - nodes[3].x) <=0.1 && nodes[3].predY <= nodes[3].y)						{														if(Math.abs(nodes[4].succX - nodes[4].x) <=0.1 && nodes[4].succY >= nodes[4].y)							{																if(Math.abs(nodes[5].predY == nodes[5].y) <=1 && nodes[5].predX >= nodes[5].x)								{																		if(Math.abs(nodes[6].succY == nodes[6].y) <=1 && nodes[6].succX <= nodes[6].x)									{																				if(Math.abs(nodes[7].predX == nodes[7].x) <=1 && nodes[7].predY >= nodes[7].y)										{																						if(Math.abs(Math.abs(nodes[6].y - nodes[1].y) - Math.abs(nodes[5].y - nodes[2].y)) <= 0.1)											{																								if(Math.ceil(nodes[0].y - nodes[0].succY) > 0 || Math.ceil(nodes[3].y - nodes[3].predY) > 0 || Math.ceil(nodes[4].succY - nodes[4].y) > 0 || Math.ceil(nodes[7].predY - nodes[7].y) > 0)													return 1;												else																							return 2;											}										}									}								}							}						}					}				}			}								return 2;	}	return 3;}//Parse all path related propertiesfunction __parsePath(currentGradientSel){	var xml = "", GradNodes, OpacityNodes;	var KnockOutCaseForShadows = false;	if(ObjectReference.effectList)	{		var EffectsList = ObjectReference.effectList;		KnockOutCaseForShadows = __CheckForKnockOutShadow(EffectsList);		xml += __setBoxShadowProperty(EffectsList, "Artwork", KnockOutCaseForShadows, currentGradientSel);		xml += __setMicrosoftGlowProperty(EffectsList, "box-shadow:", currentGradientSel);			}		if(currentGradientSel.pathAttributes.brush)		xml += __ExtractBrushProperties(currentGradientSel, KnockOutCaseForShadows);	if(currentGradientSel.pathAttributes.fill && currentGradientSel.pathAttributes.fill.gradient)	{	 GradNodes = currentGradientSel.pathAttributes.fill.gradient.nodes;	 OpacityNodes = currentGradientSel.pathAttributes.fill.gradient.opacityNodes;	}	 xml += __parseGradient(currentGradientSel, 0, 3, true, true, true, true, "", "", 		 GradNodes, OpacityNodes, 0, 0, 0, 0, false, 0);//	xml += __ExtractOpacity(currentGradientSel);	return xml + "</object>";}//--------------------------------------------------------------------// FUNCTION://   __ExtractBrushProperties//// DESCRIPTION://   Extracts the border related CSS properties//// ARGUMENTS://   currentGradientSel -   The currently selected object//    KnockOutCaseForShadows- Whether Knock out check box is on, on any of the filters// RETURNS://   XML containing the border css properties//--------------------------------------------------------------------function __ExtractBrushProperties(currentGradientSel, KnockOutCaseForShadows){	var xml = "";	var styleName = currentGradientSel.pathAttributes.brush.category;	var BrushDiameter = currentGradientSel.pathAttributes.brush.diameter;	var isBasic = styleName.match('Basic');	var isDashed = styleName.match('Dashed');	var isPencil = styleName.match('Pencil');  var fillColorCSS = "";  var ObjectOpacity = 100;  fillColor = currentGradientSel.pathAttributes.brushColor;  if(fillColor.substr(7,2))    ObjectOpacity = parseInt(fillColor.substr(7,2), 16)/255 * 100;  	var Opacity = Math.round(ObjectOpacity * (currentGradientSel.opacity/100))/100;	if(Opacity == 0 || KnockOutCaseForShadows)	{	  	  fillColorCSS = "transparent";	}	else	{    fillColorCSS = "rgb(";    if(Opacity < 1)      fillColorCSS = "rgba(";      fillColorCSS += parseInt(fillColor.substr(1,2), 16);    fillColorCSS += ",";    fillColorCSS += parseInt(fillColor.substr(3,2), 16);    fillColorCSS += ",";    fillColorCSS += parseInt(fillColor.substr(5,2), 16);    if(Opacity < 1)    {      fillColorCSS += ",";      fillColorCSS += Opacity;    }    fillColorCSS += ")";	}	xml += "<property id = 'BorderColor' >";	xml += "<string>";	xml += fillColorCSS;	xml += "</string>";	xml += "</property>";	xml += "<property id = 'BorderColorCSS' >";	xml += "<string1>";	xml += "border-color:";	xml += fillColorCSS;	xml += ";\n\n";	xml += "</string1>";	xml += "</property>";	xml += "<property id = 'BorderWidth' >";	xml += "<string>";	xml += currentGradientSel.pathAttributes.brush.diameter;	xml += "px";	xml += "</string>";	xml += "</property>";	xml += "<property id = 'BorderWidthCSS' >";	xml += "<string1>";	xml += "border-width:";	xml += BrushDiameter;	xml += "px;\n\n";	xml += "</string1>";	xml += "</property>";	xml += "<property id = 'BorderStyle' >";	xml += "<string>";	if(isDashed)	{		var NumDashes = currentGradientSel.pathAttributes.brush.numDashes;		if(NumDashes == 0)			xml += "Dotted";				else			xml += "Dashed";	}	else		xml += "solid";	xml += "</string>";	xml += "</property>";						xml += "<property id = 'BorderStyleCSS' >";	xml += "<string1>";	xml += "border-style:";	if(isDashed)	{		var NumDashes = currentGradientSel.pathAttributes.brush.numDashes;		if(NumDashes == 0)			xml += "dotted;";				else			xml += "dashed;";	}	else		xml += "solid;";	xml += "\n\n";	xml += "</string1>";	xml += "</property>";		return xml;}//--------------------------------------------------------------------// FUNCTION://   __parseGradient//// DESCRIPTION://  Extracts linear, radial, rectangle, ellipse gradient CSS properties //// ARGUMENTS://   currentGradientSel- Currently selected object in the FW canvas//   rotation - Angle of the fillhandle//   IsAutoShapeRectangle - Is it a autoshape?//   ProcessLinearGradient - Is linear gradient to be processed//   ProcessEllipseGradient - is ellipse gradient to be processed?//   ProcessOperaLinearGradient - Is opera gradient to be processed?//   ProcessRadialGradient - Is radial gradient to be processed?//   RadialSizeConstant - size constant for the radii of the radial gradient//   ChooseSideForEllipse - Which side of the rectangle is closest to the major axis?//   GradNodes - gradient nodes//   OpacityNodes - opacity nodes//   percentage1 - fillhandle2.x location in terms of percentage of the sides of the rectangle//   percentage2 - fillhandle2.y location in terms of percentage of the sides of the rectangle//   percentage1Pt2, percentage2Pt2 - fillhandle3.x, fillhandle3.y//   KnockOutCaseForShadows - whether knockout shadow is present//   radius - radius of the radial gradient fill handle// RETURNS://   returns the xml containing gradient properties wrapped in it//--------------------------------------------------------------------function __parseGradient(currentGradientSel, rotation, IsAutoShapeRectangle, ProcessLinearGradient,ProcessEllipseGradient, ProcessOperaLinearGradient, ProcessRadialGradient, RadialSizeConstant, ChooseSideForEllipse, GradNodes, OpacityNodes, percentage1, percentage2, percentage1Pt2, percentage2Pt2, KnockOutCaseForShadows, radius){	var xml = "";	var PhotoshopLiveEffectsSolidFill = 0;	if(currentGradientSel.pathAttributes.fill && KnockOutCaseForShadows == false)	{	  var EffectsList = currentGradientSel.effectList;	  	for(var i = 0; EffectsList && i < EffectsList.effects.length; i++)	  {	    if(EffectsList.effects[i].EffectMoaID.match('{8eeadf50-9efe-11da-a7460800200c9a66}') && EffectsList.effects[i].EffectIsVisible)	    {	    	  if(typeof(EffectsList.effects[i].solidFill) != 'undefined')	      {	        PhotoshopLiveEffectsSolidFill = EffectsList.effects[i].solidFill;          PhotoshopLiveEffectsSolidFill = PhotoshopLiveEffectsSolidFill.split("&");          if(PhotoshopLiveEffectsSolidFill[0] == "0")            PhotoshopLiveEffectsSolidFill = 0;        }	    }    }    		switch(currentGradientSel.pathAttributes.fill.shape)		{			case "solid":			if(PhotoshopLiveEffectsSolidFill)			{                xml += __ParsePhotoshopLiveEffectsSolidFill(PhotoshopLiveEffectsSolidFill, currentGradientSel);			}      else			  xml += __SolidBackgroundColor(currentGradientSel.pathAttributes.fillColor, currentGradientSel);			break;		case "linear":			xml += "<property id = 'gradientType' >";			xml += "<string>";			var operaGradientXML = "";			operaGradientXML += "linear-gradient(";				var globalOpacity = Math.round(currentGradientSel.opacity)/100;			if(IsAutoShapeRectangle < 3)			{				operaGradientXML += -1 * Math.round(rotation);				operaGradientXML += "deg,";			}			operaGradientXML += __GetColorStops(GradNodes, OpacityNodes, currentGradientSel, 1);			operaGradientXML += ");";			xml += operaGradientXML;			xml += "</string>";			xml += "</property>";			xml += "<property id = 'gradientTypecss' >";			xml += "<string1>";			if(ProcessLinearGradient)			{        xml += "/* Firefox v3.6+ */\n";				xml += "background-image:\n";				xml += "-moz-linear-gradient(";				if(IsAutoShapeRectangle < 3)				{										xml += Math.round(percentage1 * 100);					xml += "% ";					xml += Math.round(percentage2 * 100);					xml += "% ";					xml += Math.round(rotation) * -1;					xml += "deg";					xml += ",";				}				xml += __GetColorStops(GradNodes, OpacityNodes, currentGradientSel, 1);				xml += ");";			}			xml += " ";			xml += "\n\n";      xml += "/* safari v4.0+ and by Chrome v3.0+ */\n";			xml += "background-image:\n";			xml += "-webkit-gradient(linear,";				if(IsAutoShapeRectangle < 3)			{				xml += Math.round(percentage1 * 100);				xml += "% ";				xml += Math.round(percentage2 * 100);				xml += "%,";				xml += Math.round(percentage1Pt2 * 100);				xml += "% ";				xml += Math.round(percentage2Pt2 * 100);				xml += "%,";			}			xml += __GetColorStops(GradNodes, OpacityNodes, currentGradientSel, 2);			xml += ");\n\n";      xml += "/* Chrome v10.0+ and by safari nightly build*/\n";			xml += "background-image:\n";											xml += "-webkit-";			xml += operaGradientXML;			if(ProcessOperaLinearGradient)			{				xml += "\n\n";        xml += "/* Opera v11.10+ */\n";				xml += "background-image:\n";				xml += "-o-";				xml += operaGradientXML;				xml += "\n\n";			}			xml += "/* IE v10+ */\n";			xml += "background-image:";			xml += "-ms-";			xml += operaGradientXML;			xml += "\n\n";						xml += "background-image:\n";			xml += operaGradientXML;			xml += "\n\n";			var StartColorIndex = 0, EndColorIndex = GradNodes.length - 1, StartOpacityIndex = 0, EndOpacityIndex = OpacityNodes.length - 1;			xml += "progid:DXImageTransform.Microsoft.gradient( startColorstr = ";			xml += "#";			//alert(rotation);			if(!(Math.abs(Math.round(180 - Math.abs(rotation))) > 3) || (Math.abs(Math.round(90 + rotation)) < 3) || (rotation >= -180 && rotation <= -90))			{				StartColorIndex = GradNodes.length - 1;				EndColorIndex = 0;				StartOpacityIndex = OpacityNodes.length - 1;				EndOpacityIndex = 0;			}      var StartOpacity = OpacityNodes[StartOpacityIndex].color.substr(7,2);      if(StartOpacity)      {        StartOpacity = Math.round(parseInt(StartOpacity, 16) * globalOpacity);        StartOpacity = StartOpacity.toString(16);      }      else      {        StartOpacity = Math.round(parseInt("ff", 16) * globalOpacity);        StartOpacity = StartOpacity.toString(16);      }      xml += StartOpacity;			xml += GradNodes[StartColorIndex].color.substr(1,6);			xml += ",";			xml += "endColorstr =";			xml += "#";      var EndOpacity = OpacityNodes[EndOpacityIndex].color.substr(7,2);      if(EndOpacity)      {        EndOpacity = Math.round(parseInt(EndOpacity, 16) * globalOpacity);        EndOpacity = EndOpacity.toString(16);      }      else      {        EndOpacity = Math.round(parseInt("ff", 16) * globalOpacity);        EndOpacity = EndOpacity.toString(16);      }      xml += EndOpacity;				xml += GradNodes[EndColorIndex].color.substr(1,6);						if(IsAutoShapeRectangle < 3)			{				xml += ",";				if(Math.abs(90 - Math.abs(rotation)) <= 3 || (Math.abs(rotation) >= 90 && Math.abs(rotation) <= 160) || Math.abs(160 - Math.abs(rotation)) <= 3)					xml += "GradientType = 0);";				else					xml += "GradientType = 1);";			}			else			{				xml += ");";			}			xml += "</string1>";			xml += "</property>";			break;		case "rectangular":			var AlphaFilterXML = "";			xml += "<property id = 'gradientType' >";			xml += "<string>";			AlphaFilterXML += __GetMicrosoftAlphaFilterXML(currentGradientSel, OpacityNodes, 3, false);			xml += AlphaFilterXML;			xml += "</string>";			xml += "</property>";						xml += "<property id = 'gradientTypecss' >";			xml += "<string1>";			xml += AlphaFilterXML;			xml += "</string1>";			xml += "</property>";			break;		case "radial":				xml += "<property id = 'gradientType' >";				xml += "<string>";				var W3CRadialGradientCSS = "";				W3CRadialGradientCSS += "radial-gradient(";				if(IsAutoShapeRectangle < 3)					{						W3CRadialGradientCSS += Math.round(percentage1 * 100);						W3CRadialGradientCSS += "% ";						W3CRadialGradientCSS += Math.round(percentage2 * 100);						W3CRadialGradientCSS += "%,";						W3CRadialGradientCSS += "circle ";						W3CRadialGradientCSS +=RadialSizeConstant;						W3CRadialGradientCSS += ", ";					}				W3CRadialGradientCSS += __GetColorStops(GradNodes, OpacityNodes, currentGradientSel, 1);				W3CRadialGradientCSS += ");";				xml += W3CRadialGradientCSS;				xml += "</string>";				xml += "</property>";				xml += "<property id = 'gradientTypecss' >";				xml += "<string1>";				if(ProcessRadialGradient)				{	          xml += "/* Firefox v3.6+ */\n";					xml += "background-image:\n";									xml += "-moz-radial-gradient(";							if(IsAutoShapeRectangle < 3)					{						xml += Math.round(percentage1 * 100);						xml += "% ";						xml += Math.round(percentage2 * 100);						xml += "%,";						xml += "circle ";						xml +=RadialSizeConstant;						xml += ",";					}					xml += __GetColorStops(GradNodes, OpacityNodes, currentGradientSel, 1);					xml += ");";				}										xml += " ";					xml += "\n\n";          xml += "/* Safari v4.0+ and by Chrome v3.0+ */\n";					xml += "background-image:\n";					xml += "-webkit-gradient(radial,";										if(IsAutoShapeRectangle < 3)						{												xml += Math.round(percentage1 * 100);						xml += "% ";												xml += Math.round(percentage2 * 100);						xml += "%,";						xml += "0,";						xml += Math.round(percentage1 * 100);						xml += "% ";						xml += Math.round(percentage2 * 100);						xml += "%,";						xml += radius;						xml += ",";					}										xml += __GetColorStops(GradNodes, OpacityNodes, currentGradientSel, 2);														xml += ");";					xml += "\n\n";          xml += "/* Safari v6.0+ and by Chrome v10.0+ */\n";					xml += "background-image:\n";					xml += "-webkit-";					xml += W3CRadialGradientCSS;					xml += "\n\n";					xml += "/* IE v10+ */\n";					xml += "background-image:";					xml += "-ms-";					xml += W3CRadialGradientCSS;					xml += "\n\n";											xml += "background-image:\n";					xml += W3CRadialGradientCSS;					xml += "\n\n";					xml += __GetMicrosoftAlphaFilterXML(currentGradientSel, OpacityNodes, 2, false);										xml += "</string1>";					xml += "</property>";						break;		case "elliptical":			if(ProcessEllipseGradient)			{								xml += "<property id = 'gradientType' >";				xml += "<string>";				var W3CEllipseGradientCSS = "";				W3CEllipseGradientCSS += "radial-gradient(";				if(IsAutoShapeRectangle < 3)				{					W3CEllipseGradientCSS += Math.round(percentage1 * 100);					W3CEllipseGradientCSS += "% ";					W3CEllipseGradientCSS += Math.round(percentage2 * 100);					W3CEllipseGradientCSS += "%,";					W3CEllipseGradientCSS += ChooseSideForEllipse;					W3CEllipseGradientCSS += ",";				}				W3CEllipseGradientCSS += __GetColorStops(GradNodes, OpacityNodes, currentGradientSel, 1);				W3CEllipseGradientCSS += ");";				xml += W3CEllipseGradientCSS;				xml += "</string>";				xml += "</property>";				xml += "<property id = 'gradientTypecss' >";				xml += "<string1>";				xml += "\n";        xml += "/* Firefox v3.6+ */\n";				xml += "background-image:\n";				xml += "-moz-radial-gradient(";				if(IsAutoShapeRectangle < 3)				{					xml += Math.round(percentage1 * 100);					xml += "% ";					xml += Math.round(percentage2 * 100);					xml += "%,";					xml += ChooseSideForEllipse;					xml += ",";				}				xml += __GetColorStops(GradNodes, OpacityNodes, currentGradientSel, 1);				xml += ");";				xml += "\n\n";        xml += "/* Safari v6.0+ and by Chrome v10.0+ */\n";				xml += "background-image:\n";				xml += "-webkit-";				xml += W3CEllipseGradientCSS;				xml += "\n\n";				xml += "/* IE v10+ */\n";				xml += "background-image:";				xml += "-ms-";				xml += W3CEllipseGradientCSS;				xml += "\n\n";									xml += "background-image:\n";				xml += W3CEllipseGradientCSS;				xml += "\n\n";				xml += "</string1>";				xml += "</property>";		}			break;		case "web dither":			xml += __SolidBackgroundColor(currentGradientSel.pathAttributes.fillColor, currentGradientSel);			break;		default:			break;		}	}	return xml;}//--------------------------------------------------------------------// FUNCTION://   __GetWidthHeightXML//// DESCRIPTION://  Extracts width and height CSS properties //// ARGUMENTS://   Width- Width of the rectangle//   Height- height of the rectangle//  // RETURNS://   returns the xml containing Width and height properties//--------------------------------------------------------------------function __GetWidthHeightXML(width, height){	var xml = "";	xml += "<property id = 'RectangleWidth' >";	xml += "<string>";	xml += Math.round(width);	xml += "px";	xml += "</string>";	xml += "</property>";	xml += "<property id = 'RectangleWidthCSS' >";	xml += "<string1>";	xml += "width:";	xml += Math.round(width);	xml += "px;\n\n";	xml += "</string1>";	xml += "</property>";	xml += "<property id = 'RectangleHeight' >";	xml += "<string>";						xml += Math.round(height);	xml += "px";	xml += "</string>";	xml += "</property>";	xml += "<property id = 'RectangleHeightCSS' >";	xml += "<string1>";	xml += "height:";	xml += Math.round(height);	xml += "px;";	xml += "\n\n";	xml += "</string1>";	xml += "</property>";	return xml;	}//Get the radius of the gradientfunction __GetRadius(Pt1, Pt2){	return (Math.sqrt(((Pt2.y - Pt1.y)*(Pt2.y - Pt1.y))+((Pt2.x - Pt1.x)*(Pt2.x - Pt1.x))));}//Check if the matrrix is identityfunction __CheckForIdentity(tMatrix){	return (tMatrix[0] == 1 && tMatrix[1] == 0 && tMatrix[3] == 0 && tMatrix[4] == 1);}//Get the Microsoft DropShadow stopsfunction __GetMicrosoftBoxShadowXML(EffectsList, XDistance, YDistance, i, KnockOutCaseForShadows, currentSelection){	var MicrosoftDropShadow = "";	MicrosoftDropShadow += "OffX = ";	MicrosoftDropShadow += XDistance;	MicrosoftDropShadow += ",";	MicrosoftDropShadow += "OffY = ";	MicrosoftDropShadow += YDistance;	MicrosoftDropShadow += ",";	MicrosoftDropShadow += "Color = ";	MicrosoftDropShadow += "#";	var globalOpacity = 1;	if(typeof(currentSelection) != 'undefined' && typeof(currentSelection.opacity) != 'undefined')		globalOpacity = currentSelection.opacity/100;  var effectiveOpacity = 100;	if(EffectsList.effects[i].ShadowColor.length <= 7)	{	    effectiveOpacity = Math.round(parseInt("ff", 16) * globalOpacity);			MicrosoftDropShadow += effectiveOpacity.toString(16);	}	else	{  	    effectiveOpacity = Math.round(parseInt(EffectsList.effects[i].ShadowColor.substr(7,2), 16) * globalOpacity);			MicrosoftDropShadow += effectiveOpacity.toString(16);	}			MicrosoftDropShadow += EffectsList.effects[i].ShadowColor.substr(1,6);	if(KnockOutCaseForShadows)		MicrosoftDropShadow += ",Positive = false";	else		MicrosoftDropShadow += ",Positive = true";	MicrosoftDropShadow += ")";	return MicrosoftDropShadow;}//Get the glow width parameterfunction __SetGlowWidth(EffectsList){	if(EffectsList)	{		var SetGlowWidth = 0;		for(var i = 0; i < EffectsList.effects.length; i++)		{		  if(EffectsList.effects[i].EffectMoaID.match('{7fe61102-6ce2-11d1-8c76000502701850}') && EffectsList.effects[i].BevelType == 4)		  {		    return (EffectsList.effects[i].GlowWidth + EffectsList.effects[i].MaskSoftness);		  }		}	}	return 0;}//Compute transformed x co-ordinatefunction __ComputeTransformPointX(pt, Matrix){	return Matrix[0] * pt.x + Matrix[3] * pt.y + Matrix[6];}//Compute the transformed y co-ordinatefunction __ComputeTransformPointY(pt, Matrix){	return Matrix[1] * pt.x + Matrix[4] * pt.y + Matrix[7];}//--------------------------------------------------------------------// FUNCTION://   __ExtractEffectsListProperties//// DESCRIPTION://  Extracts filter effect properties//// ARGUMENTS://   EffectsList- list of effects applied to the object //   KnockOutCaseForShadows - whether knockout filter is turned on//   ObjectType- Whether the object is text or Artwork////  // RETURNS://   returns the xml containing filter effect properties//--------------------------------------------------------------------function __ExtractEffectsListProperties(EffectsList, KnockOutCaseForShadows, ObjectType, ObjectTag, currentSelection){	if(EffectsList && EffectsList.effects.length != 0)	{		var xml = "";		var temp = __setBoxShadowProperty(EffectsList, ObjectType, KnockOutCaseForShadows, currentSelection);		if(temp != null)			xml += temp;		//temp = __setMicrosoftGlowProperty(EffectsList, ObjectTag);		//if(temp != null)		//	xml += temp;			return xml;	}	return "";}//--------------------------------------------------------------------// FUNCTION://   __CheckIfDoubleBytePresent//// DESCRIPTION://   Checks if iput string has a double byte in it//// ARGUMENTS://   String - //// RETURNS://   true if double byte present//--------------------------------------------------------------------/*function __CheckIfDoubleBytePresent(font){  var ReturnFont = "";  for(var i = 0; i < font.length; i++)  {    if(font.charCodeAt(i) > 255)			return true;           }	return false;}*/function __StripXMLForJQuery(xml){  var splitString = xml.split("<string1>");  var CSSCode = "";  var splitAgain = "";  var i = 1;  while(typeof splitString[i] != 'undefined')  {    splitAgain =  splitString[i].split("</string1>");    if(typeof splitAgain[0] != 'undefined')      CSSCode += splitAgain[0];    i++;  }  var FormattedCSS = __FormatIEStringForJQuery(0, CSSCode);  return FormattedCSS;}function __FormatIEStringForJQuery(ObjectReference, CSSCode){  var SubString = CSSCode.split(";");  var i = 0;  var MicrosoftFinalCSS = "";  var RestOfTheCSS = "";  var FirstIETag = true;  while(typeof SubString[i] != 'undefined')  {        if(SubString[i].search("progid") > -1)    {      MicrosoftFinalCSS += SubString[i];    }    else    {      if(SubString[i].search(":") > -1)        RestOfTheCSS += SubString[i] + ";";    }    i++;  }  var ReturnCSSCode = "";  ReturnCSSCode = RestOfTheCSS;  if(MicrosoftFinalCSS.search("progid") > -1)  {    while(MicrosoftFinalCSS.match("filter:"))      MicrosoftFinalCSS = MicrosoftFinalCSS.replace("filter:", "");    //MicrosoftFinalCSS = MicrosoftFinalCSS.replace(",", "");	  ReturnCSSCode += "\nfilter:" + MicrosoftFinalCSS + ";\n";	  }    return ReturnCSSCode;  }//--------------------------------------------------------------------// FUNCTION://   __AdjustBorderRadiusAccordingToBrushPlacement//// DESCRIPTION://   //// ARGUMENTS://   //// RETURNS://   //--------------------------------------------------------------------function __AdjustBorderRadiusAccordingToBrushPlacement(currentGradientSel, BorderRadius){  if(currentGradientSel.pathAttributes.brush)  {        if(currentGradientSel.pathAttributes.brushPlacement == "center")    {        BorderRadius += (currentGradientSel.pathAttributes.brush.diameter / 2);    }    else if(currentGradientSel.pathAttributes.brushPlacement == "outside")    {      BorderRadius += (currentGradientSel.pathAttributes.brush.diameter);    }  }  return  Math.round(BorderRadius);}//--------------------------------------------------------------------// FUNCTION://   __BorderRadiusInPercentage//// DESCRIPTION://   returns the border radius in terms of percentages//	  // ARGUMENTS://   Width      //   Height//   BorderRadius - Border Radius In Pixels// RETURNS://   border radius in percentages//--------------------------------------------------------------------function __BorderRadiusInPercentage(Width, Height, BorderRadius){  var ReturnValue = "";  var PercentageOnWidth = BorderRadius/Width;  var PercentageOnHeight = PercentageOnWidth * Width/Height;  PercentageOnWidth = Math.floor(PercentageOnWidth * 100);  PercentageOnHeight = Math.floor(PercentageOnHeight * 100);  if(PercentageOnWidth > 0 || PercentageOnHeight > 0)    ReturnValue = PercentageOnWidth +"%"+ "\/" + PercentageOnHeight + "%";  else    ReturnValue = 0;    return ReturnValue;}//--------------------------------------------------------------------// FUNCTION://   __IndentTheCode//// DESCRIPTION://   //// ARGUMENTS://   //// RETURNS://   //--------------------------------------------------------------------function __IndentTheCode(CSSCode){  CSSCode = CSSCode.replace(/\n\n/g, "");  CSSCode = CSSCode.replace("background-color", "background");  var SplitCode = CSSCode.split("filter:");  var W3CPseudoCompliantCSSCode = SplitCode[0];  W3CPseudoCompliantCSSCode = W3CPseudoCompliantCSSCode.split(";");  var CleanCSSCode = new String();  var i = 0;  while(W3CPseudoCompliantCSSCode[i].match(":"))  {    var Comment = "";    var MainCode = W3CPseudoCompliantCSSCode[i].toString();    if(W3CPseudoCompliantCSSCode[i].match("*"))    {      Comment = W3CPseudoCompliantCSSCode[i].split("*/");      MainCode = Comment[1];    }	  MainCode = MainCode.replace(/\n/g, "\n\t");	  if(MainCode.match("gradient"))	  {		MainCode = MainCode.replace(/\trgb/g, "\t\t\t\t\trgb");		MainCode = MainCode.replace(/\nrgb/g, "\t\t\t\t\trgb");		  	  }    CleanCSSCode += ("\t" + MainCode + ";\n\n");    i++;  }  	CleanCSSCode = CleanCSSCode.replace(/\n\t\n\t/g, "\t");	CleanCSSCode = CleanCSSCode.replace(/\n\n/g, "\n");   return CleanCSSCode;}//--------------------------------------------------------------------// FUNCTION://   __ParsePhotoshopLiveEffectsShadowParse//// DESCRIPTION://   Parses the photoshop live effects shadow object//	  // ARGUMENTS://   PSLiveEffectsShadowObject - the shadow component of the PS Live effects object// RETURNS://   css code corresponding to the shadow effects//--------------------------------------------------------------------function __ParsePhotoshopLiveEffectsShadowParse(PSLiveEffectsShadowObject, currentSelection){    var ShadowOpacity = PSLiveEffectsShadowObject[1];    var ShadowAngle = PSLiveEffectsShadowObject[3];    var ShadowDistance = PSLiveEffectsShadowObject[5];    var ShadowSize = PSLiveEffectsShadowObject[6];    var ShadowSpread = PSLiveEffectsShadowObject[7];    var ShadowRGBColor = PSLiveEffectsShadowObject[11].split(";");    var ShadowRed = ShadowRGBColor[1];    var ShadowGreen = ShadowRGBColor[2];    var ShadowBlue = ShadowRGBColor[3];  	  	var ShadowAngle = (ShadowAngle * Math.PI) / 180 + ( Math.PI)/2 + Math.PI;    var XDistance = Math.round(ShadowDistance * Math.sin(ShadowAngle));    var YDistance = Math.round(ShadowDistance * Math.cos(ShadowAngle));	if(typeof(currentSelection) != 'undefined' && typeof(currentSelection.opacity) != 'undefined')		ShadowOpacity = Math.round(ShadowOpacity * currentSelection.opacity/100);      var ReturnXML = "";  ReturnXML += XDistance;//Math.round(__ComputeTransformPointX(pt, Matrix));  ReturnXML += "px ";  ReturnXML += YDistance;//Math.round(__ComputeTransformPointY(pt, Matrix));  ReturnXML += "px ";  ReturnXML += Math.round((1 - ShadowSpread/ 100) * ShadowSize);  ReturnXML += "px ";  if(currentSelection != "[object Text]")  {		ReturnXML += Math.round(ShadowSize * ShadowSpread/ 100);  	  ReturnXML += "px ";	}	if(ShadowOpacity < 100)    ReturnXML += "rgba(";  else    ReturnXML += "rgb(";  ReturnXML += Math.round(ShadowRed);  ReturnXML += ",";  ReturnXML += Math.round(ShadowGreen);  ReturnXML += ",";  ReturnXML += Math.round(ShadowBlue);  if(ShadowOpacity < 100)	{		ReturnXML += ",";    ReturnXML += ShadowOpacity/100;	}//  else//  {//     ReturnXML += ",";//     ReturnXML += "1";//  }  ReturnXML += ")";  return ReturnXML;}//--------------------------------------------------------------------// FUNCTION://   __ParsePhotoshopLiveEffectsGlowParse//// DESCRIPTION://   Parses the photoshop live effects Glow object//	  // ARGUMENTS://   PSLiveEffectsGlowObject - the Glow component of the PS Live effects object// RETURNS://   css code corresponding to the shadow effects//--------------------------------------------------------------------function __ParsePhotoshopLiveEffectsGlowParse(PSLiveEffectsGlowObject, currentSelection){    var GlowParameters = PSLiveEffectsGlowObject[3].split(":");    var GlowOpacity = GlowParameters[0];    var GlowSpread = GlowParameters[1];    var GlowSize = GlowParameters[2];    var GlowRange = GlowParameters[5];    var GlowColors = PSLiveEffectsGlowObject[5].split(";");    var RedColor = GlowColors[1];    var GreenColor = GlowColors[2];    var BlueColor = GlowColors[3];	if(typeof(currentSelection) != 'undefined' && typeof(currentSelection.opacity) != 'undefined')		GlowOpacity = Math.round(GlowOpacity * currentSelection.opacity/100);    var XDistance = 0;    var YDistance = 0;      var ReturnXML = "";  ReturnXML += XDistance;//Math.round(__ComputeTransformPointX(pt, Matrix));  ReturnXML += "px ";  ReturnXML += YDistance;//Math.round(__ComputeTransformPointY(pt, Matrix));  ReturnXML += "px ";  ReturnXML += Math.round((1 - GlowSpread/ 100) * GlowSize);  ReturnXML += "px ";  if(currentSelection != "[object Text]")  {		ReturnXML += Math.round(GlowSpread/ 100 * GlowSize);  	  ReturnXML += "px ";	}	if(GlowOpacity < 100)    ReturnXML += "rgba(";  else    ReturnXML += "rgb(";  ReturnXML += Math.round(RedColor);  ReturnXML += ",";  ReturnXML += Math.round(GreenColor);  ReturnXML += ",";  ReturnXML += Math.round(BlueColor);  if(GlowOpacity < 100)	{		ReturnXML += ",";    ReturnXML += GlowOpacity/100;	}//  else//  {//     ReturnXML += ",";//     ReturnXML += "1";//  }  ReturnXML += ")";  return ReturnXML;}//--------------------------------------------------------------------// FUNCTION://   __ParsePhotoshopLiveEffectsMSShadow//// DESCRIPTION://   Parses the photoshop live effects shadow object//	  // ARGUMENTS://   PSLiveEffectsShadowObject - the shadow component of the PS Live effects object//   KnockOutCaseForShadows - whether knock out checkbox is checked// RETURNS://   IE filter css code corresponding to the shadow effects//--------------------------------------------------------------------function __ParsePhotoshopLiveEffectsMSShadow(PSLiveEffectsShadowObject, KnockOutCaseForShadows, currentSelection){    var ShadowOpacity = PSLiveEffectsShadowObject[1];    var ShadowAngle = PSLiveEffectsShadowObject[3];    var ShadowDistance = PSLiveEffectsShadowObject[5];    var ShadowRGBColor = PSLiveEffectsShadowObject[11].split(";");    var ShadowRed = ShadowRGBColor[1];    var ShadowGreen = ShadowRGBColor[2];    var ShadowBlue = ShadowRGBColor[3];  	  	ShadowAngle = (ShadowAngle * Math.PI) / 180 + ( Math.PI)/2 + Math.PI;	if(typeof(currentSelection) != 'undefined' && typeof(currentSelection.opacity) != 'undefined')		ShadowOpacity = Math.round(ShadowOpacity * currentSelection.opacity/100);    var XDistance = Math.round(ShadowDistance * Math.sin(ShadowAngle));    var YDistance = Math.round(ShadowDistance * Math.cos(ShadowAngle));	var MicrosoftDropShadow = "";	MicrosoftDropShadow += "OffX = ";	MicrosoftDropShadow += XDistance;	MicrosoftDropShadow += ",";	MicrosoftDropShadow += "OffY = ";	MicrosoftDropShadow += YDistance;	MicrosoftDropShadow += ",";	MicrosoftDropShadow += "Color = ";	MicrosoftDropShadow += "#";	  MicrosoftDropShadow += parseFloat(Math.round((ShadowOpacity/100) * 255)).toString(16);	  if(ShadowRed < 16)	    MicrosoftDropShadow += "0";	    	  MicrosoftDropShadow += parseFloat(ShadowRed).toString(16);	  if(ShadowGreen < 16)	    MicrosoftDropShadow += "0";	    	  MicrosoftDropShadow += parseFloat(ShadowGreen).toString(16);	  	  if(ShadowBlue < 16)	    MicrosoftDropShadow += "0";    MicrosoftDropShadow += parseFloat(ShadowBlue).toString(16);	if(KnockOutCaseForShadows)		MicrosoftDropShadow += ",Positive = false";	else		MicrosoftDropShadow += ",Positive = true";	MicrosoftDropShadow += ")";	return MicrosoftDropShadow;}//--------------------------------------------------------------------// FUNCTION://   __ParsePhotoshopLiveEffectsMSGlow//// DESCRIPTION://   Parses the photoshop live effects glow object//	  // ARGUMENTS://   PSLiveEffectsGlowObject - the GLow component of the PS Live effects object// RETURNS://   IE filter css code corresponding to the shadow effects//--------------------------------------------------------------------function __ParsePhotoshopLiveEffectsMSGlow(PSLiveEffectsGlowObject, currentSelection){  var GlowParameters = PSLiveEffectsGlowObject[3].split(":");  var GlowOpacity = GlowParameters[0];  var GlowSpread = GlowParameters[1];  var GlowSize = GlowParameters[2];  var GlowRange = GlowParameters[5];  var GlowColors = PSLiveEffectsGlowObject[5].split(";");  var RedColor = GlowColors[1];  var GreenColor = GlowColors[2];  var BlueColor = GlowColors[3];  var MicrosoftGlow = "";  if(typeof(currentSelection) != 'undefined' && typeof(currentSelection.opacity) != 'undefined')	GlowOpacity = Math.round(GlowOpacity * currentSelection.opacity/100);  MicrosoftGlow += "progid:DXImageTransform.Microsoft.Glow(";	  MicrosoftGlow += "Color = ";  MicrosoftGlow += "#";  MicrosoftGlow += parseFloat(Math.round((GlowOpacity/100) * 255)).toString(16);  if(RedColor < 16)    MicrosoftGlow += "0";  MicrosoftGlow += parseFloat(RedColor).toString(16);  if(GreenColor < 16)    MicrosoftGlow += "0";      MicrosoftGlow += parseFloat(GreenColor).toString(16);	    if(BlueColor < 16)    MicrosoftGlow += "0";  MicrosoftGlow += parseFloat(Math.round(BlueColor)).toString(16);  MicrosoftGlow += " ,";  MicrosoftGlow += "Strength = ";  MicrosoftGlow += Math.round(GlowSize);  MicrosoftGlow += ")";  return MicrosoftGlow;}//--------------------------------------------------------------------// FUNCTION://   __ParsePhotoshopLiveEffectsStroke//// DESCRIPTION://   Parses the photoshop live effects glow object//	  // ARGUMENTS://   PSLiveEffectsGlowObject - the GLow component of the PS Live effects object// RETURNS://   IE filter css code corresponding to the shadow effects//--------------------------------------------------------------------function __ParsePhotoshopLiveEffectsStroke(PSLiveEffectsStrokeObject, KnockOutCaseForShadows, currentSelection){  var Opacity = Math.round(PSLiveEffectsStrokeObject[1])/100;  var BorderWidth = Math.round(PSLiveEffectsStrokeObject[2]);  var RGBColors = PSLiveEffectsStrokeObject[4].split(";");  var RedColor = Math.round(RGBColors[1]);  var GreenColor = Math.round(RGBColors[2]);  var BlueColor = Math.round(RGBColors[3]);  var colorcss = "rgb(";  var xml = "";  if(typeof(currentSelection) != 'undefined' && typeof(currentSelection.opacity) != 'undefined')	Opacity = Math.round(Opacity * currentSelection.opacity)/100;	  	xml += "<property id = 'BorderColor' >";	xml += "<string>";	if(KnockOutCaseForShadows)	{			colorcss = "transparent";	}	else	{	  if(Opacity < 1)	  {	    colorcss = "rgba(";	  }	  colorcss += RedColor;	  colorcss += ",";	  colorcss += GreenColor;	  colorcss += ",";	  colorcss += BlueColor;	  if(Opacity < 1)	  {	    colorcss += ",";	    colorcss += Opacity;	    	  }	  colorcss += ");"; 	}  xml += colorcss;	xml += "</string>";	xml += "</property>";	xml += "<property id = 'BorderColorCSS' >";	xml += "<string1>";	xml += "border-color:";	if(KnockOutCaseForShadows)		xml += "transparent;";	else  {    xml += colorcss;  }	xml += "\n\n";	xml += "</string1>";	xml += "</property>";	xml += "<property id = 'BorderWidth' >";	xml += "<string>";	xml += BorderWidth;	xml += "px";	xml += "</string>";	xml += "</property>";	xml += "<property id = 'BorderWidthCSS' >";	xml += "<string1>";	xml += "border-width:";	xml += BorderWidth;	xml += "px;\n\n";	xml += "</string1>";	xml += "</property>";	xml += "<property id = 'BorderStyle' >";	xml += "<string>";	xml += "solid";	xml += "</string>";	xml += "</property>";						xml += "<property id = 'BorderStyleCSS' >";	xml += "<string1>";	xml += "border-style:";	xml += "solid;";	xml += "\n\n";	xml += "</string1>";	xml += "</property>";	return xml;}//--------------------------------------------------------------------// FUNCTION://   __ParsePhotoshopLiveEffectsSolidFill//// DESCRIPTION://   Parses the photoshop live effects solid object//	  // ARGUMENTS://   PSLiveEffectsGlowObject - the solid fill component of the PS Live effects object// RETURNS://   xml containing the solid fill color property//--------------------------------------------------------------------function __ParsePhotoshopLiveEffectsSolidFill(PSLiveEffectsSolidFillObject, currentSelection){  var SolidFill = PSLiveEffectsSolidFillObject[3].split(";");  var Opacity = PSLiveEffectsSolidFillObject[1];  var fillColorCSS = "rgb(";  var RedColor = Math.round(SolidFill[1]);  var GreenColor = Math.round(SolidFill[2]);;  var BlueColor = Math.round(SolidFill[3]);  var Returnxml = "";  if(typeof(currentSelection) != 'undefined' && typeof(currentSelection.opacity) != 'undefined')  	Opacity = Math.round(Opacity * currentSelection.opacity/100);		Returnxml += "<property id = 'BGColor' >";	Returnxml += "<string>";	if(Opacity < 100)	  fillColorCSS = "rgba("  fillColorCSS += RedColor;  fillColorCSS += ",";  fillColorCSS += GreenColor;  fillColorCSS += ",";  fillColorCSS += BlueColor;  if(Opacity < 100)  {    fillColorCSS += ",";    fillColorCSS += Math.round(Opacity)/100;    }  fillColorCSS += ")";  Returnxml += fillColorCSS;	Returnxml	+= "</string>"	Returnxml += "</property>";	Returnxml += "<property id = 'BGColorCSS' >";	Returnxml += "<string1>";	Returnxml += "background-color:";	Returnxml += fillColorCSS;	Returnxml += ";\n\n";	Returnxml	+= "</string1>"	Returnxml += "</property>";	return Returnxml;}//--------------------------------------------------------------------// FUNCTION://   __GetPSLiveEffectsObject//// DESCRIPTION://   returns the photoshop live effects object//	  // ARGUMENTS://   EffectsList -// RETURNS://   Live Effects Object//--------------------------------------------------------------------function __GetPSLiveEffectsObject(EffectsList){  	for(var i = 0; i < EffectsList.effects.length; i++)	{	  if(EffectsList.effects[i].EffectMoaID.match('{8eeadf50-9efe-11da-a7460800200c9a66}') && EffectsList.effects[i].EffectIsVisible)	    return EffectsList.effects[i];	}}//--------------------------------------------------------------------// FUNCTION://   __ParsePhotoshopLiveEffectsStrokeColor//// DESCRIPTION://   Parses the photoshop live effects stroke object//	  // ARGUMENTS://   PSLiveEffectsStrokeObject - the stroke component of the PS Live effects object// RETURNS://   color value in rgba format//--------------------------------------------------------------------function __ParsePhotoshopLiveEffectsStrokeColor(PSLiveEffectsStrokeObject, KnockOutCaseForShadows, currentSelection){  var Opacity = Math.round(PSLiveEffectsStrokeObject[1])/100;  var RGBColors = PSLiveEffectsStrokeObject[4].split(";");  var RedColor = Math.round(RGBColors[1]);  var GreenColor = Math.round(RGBColors[2]);  var BlueColor = Math.round(RGBColors[3]);  var colorcss = "rgb(";  if(typeof(currentSelection) != 'undefined' && typeof(currentSelection.opacity) != 'undefined')    Opacity = Math.round(Opacity * currentSelection.opacity)/100;	if(KnockOutCaseForShadows)	{			colorcss = "transparent";	}	else	{	  if(Opacity < 1)	  {	    colorcss = "rgba(";	  }	  colorcss += RedColor;	  colorcss += ",";	  colorcss += GreenColor;	  colorcss += ",";	  colorcss += BlueColor;	  if(Opacity < 1)	  {	    colorcss += ",";	    colorcss += Opacity;	    	  }	  colorcss += ")"; 	}  		return colorcss;}